begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* ========================================================================== *  *         Copyright (C) 2004-2006, Pier Fumagalli<http://could.it/>         *  *                            All rights reserved.                            *  * ========================================================================== *  *                                                                            *  * Licensed under the  Apache License, Version 2.0  (the "License").  You may *  * not use this file except in compliance with the License.  You may obtain a *  * copy of the License at<http://www.apache.org/licenses/LICENSE-2.0>.       *  *                                                                            *  * Unless  required  by applicable  law or  agreed  to  in writing,  software *  * distributed under the License is distributed on an  "AS IS" BASIS, WITHOUT *  * WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied.  See the *  * License for the  specific language  governing permissions  and limitations *  * under the License.                                                         *  *                                                                            *  * ========================================================================== */
end_comment

begin_package
package|package
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLEncoder
import|;
end_import

begin_comment
comment|/**  *<p>An utility class providing various static methods dealing with  * encodings and {@link Encodable} objects..</p>  *  * @author<a href="http://could.it/">Pier Fumagalli</a>  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|EncodingTools
implements|implements
name|EncodingAware
block|{
comment|/**<p>The Base-64 alphabet.</p> */
specifier|private
specifier|static
specifier|final
name|char
name|ALPHABET
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|,
literal|'='
block|}
decl_stmt|;
comment|/**<p>Deny construction of this class.</p> */
specifier|private
name|EncodingTools
parameter_list|()
block|{
block|}
comment|/* ====================================================================== */
comment|/* URL ENCODING / DECODING                                                */
comment|/* ====================================================================== */
comment|/**      *<p>Return the {@link String} representation of the specified      * {@link Encodable} object using the {@link EncodingAware#DEFAULT_ENCODING      * default encoding}.</p>      *      * throws NullPointerException if the {@link Encodable} was<b>null</b>.      */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Encodable
name|encodable
parameter_list|)
block|{
try|try
block|{
return|return
name|encodable
operator|.
name|toString
argument_list|(
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Default encoding \""
operator|+
name|DEFAULT_ENCODING
operator|+
literal|"\" not supported by the platform"
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/* ====================================================================== */
comment|/* URL ENCODING / DECODING                                                */
comment|/* ====================================================================== */
comment|/**      *<p>URL-encode the specified string.</p>      */
specifier|public
specifier|static
name|String
name|urlEncode
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|source
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
return|return
name|URLEncoder
operator|.
name|encode
argument_list|(
name|source
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/**      *<p>URL-encode the specified string.</p>      */
specifier|public
specifier|static
name|String
name|urlEncode
parameter_list|(
name|String
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|==
literal|null
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|URLEncoder
operator|.
name|encode
argument_list|(
name|source
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>URL-decode the specified string.</p>      */
specifier|public
specifier|static
name|String
name|urlDecode
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|source
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
return|return
name|URLDecoder
operator|.
name|decode
argument_list|(
name|source
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/**      *<p>URL-decode the specified string.</p>      */
specifier|public
specifier|static
name|String
name|urlDecode
parameter_list|(
name|String
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|==
literal|null
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|URLDecoder
operator|.
name|decode
argument_list|(
name|source
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/* ====================================================================== */
comment|/* BASE 64 ENCODING / DECODING                                            */
comment|/* ====================================================================== */
comment|/**      *<p>Encode the specified string in base 64 using the specified      * encoding.</p>      */
specifier|public
specifier|static
specifier|final
name|String
name|base64Encode
parameter_list|(
name|String
name|string
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
comment|/* Check the source string for null or the empty string. */
if|if
condition|(
name|string
operator|==
literal|null
condition|)
return|return
operator|(
literal|null
operator|)
return|;
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|""
return|;
comment|/* Check the encoding */
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
comment|/* Prepare the buffers that we'll use to encode in Base 64 */
specifier|final
name|byte
name|bsrc
index|[]
init|=
name|string
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
specifier|final
name|char
name|bdst
index|[]
init|=
operator|new
name|char
index|[
operator|(
name|bsrc
operator|.
name|length
operator|+
literal|2
operator|)
operator|/
literal|3
operator|*
literal|4
index|]
decl_stmt|;
comment|/* Iterate into the source in chunks of three bytes */
name|int
name|psrc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pdst
init|=
literal|0
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|psrc
operator|=
name|psrc
operator|+
literal|3
operator|)
operator|<
name|bsrc
operator|.
name|length
condition|)
block|{
comment|/* For every three bytes processed ... */
name|temp
operator|=
operator|(
operator|(
name|bsrc
index|[
name|psrc
operator|-
literal|2
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xFF0000
operator|)
operator||
operator|(
operator|(
name|bsrc
index|[
name|psrc
operator|-
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0x00FF00
operator|)
operator||
operator|(
operator|(
name|bsrc
index|[
name|psrc
index|]
operator|)
operator|&
literal|0x0000FF
operator|)
expr_stmt|;
comment|/* ... we append four bytes to the buffer */
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
comment|/* Let's check whether we still have some bytes to encode */
switch|switch
condition|(
name|psrc
operator|-
name|bsrc
operator|.
name|length
condition|)
block|{
case|case
literal|0
case|:
comment|/* Two bytes left to encode */
name|temp
operator|=
operator|(
operator|(
name|bsrc
index|[
name|psrc
operator|-
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|bsrc
index|[
name|psrc
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|10
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|<<
literal|2
operator|)
operator|&
literal|0x3c
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
literal|64
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* One byte left to encode */
name|temp
operator|=
operator|(
name|bsrc
index|[
name|psrc
operator|-
literal|2
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|>>
literal|2
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|temp
operator|<<
literal|4
operator|)
operator|&
literal|0x30
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
literal|64
index|]
expr_stmt|;
name|bdst
index|[
name|pdst
operator|++
index|]
operator|=
name|ALPHABET
index|[
literal|64
index|]
expr_stmt|;
block|}
comment|/* Convert the character array into a proper string */
return|return
operator|new
name|String
argument_list|(
name|bdst
argument_list|)
return|;
block|}
comment|/**      *<p>Encode the specified string in base 64 using the default encoding.</p>      */
specifier|public
specifier|static
specifier|final
name|String
name|base64Encode
parameter_list|(
name|String
name|string
parameter_list|)
block|{
try|try
block|{
return|return
operator|(
name|base64Encode
argument_list|(
name|string
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
operator|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**          *<p>Decode the specified base 64 string using the specified encoding.</p>          */
specifier|public
specifier|static
specifier|final
name|String
name|base64Decode
parameter_list|(
name|String
name|string
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
comment|/* Check the source string for null or the empty string. */
if|if
condition|(
name|string
operator|==
literal|null
condition|)
return|return
operator|(
literal|null
operator|)
return|;
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|""
return|;
comment|/* Check the encoding */
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
comment|/* Retrieve the array of characters of the source string. */
specifier|final
name|char
name|characters
index|[]
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
comment|/* Check the length, which must be dividible by 4. */
if|if
condition|(
operator|(
name|characters
operator|.
name|length
operator|&
literal|0x03
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid length for the "
operator|+
literal|"encoded string ("
operator|+
name|characters
operator|.
name|length
operator|+
literal|")"
argument_list|)
throw|;
comment|/* The bytes array length is 3/4th of the characters array length */
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|characters
operator|.
name|length
operator|-
operator|(
name|characters
operator|.
name|length
operator|>>
literal|2
operator|)
index|]
decl_stmt|;
comment|/*              * Since this might take a while check now for the last 4 characters              * token: it must contain at most two == and those need to be in the              * last two positions in the array (the only valid sequences are:              * "????", "???=" and "??==").              */
if|if
condition|(
operator|(
operator|(
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|4
index|]
operator|==
literal|'='
operator|)
operator|||
operator|(
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|3
index|]
operator|==
literal|'='
operator|)
operator|)
operator|||
operator|(
operator|(
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|2
index|]
operator|==
literal|'='
operator|)
operator|&&
operator|(
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|1
index|]
operator|!=
literal|'='
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid pattern for last "
operator|+
literal|"Base64 token in string to decode: "
operator|+
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|4
index|]
operator|+
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|3
index|]
operator|+
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|2
index|]
operator|+
name|characters
index|[
name|characters
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
throw|;
block|}
comment|/* Translate the Base64-encoded String in chunks of 4 characters. */
name|int
name|coff
init|=
literal|0
decl_stmt|;
name|int
name|boff
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|coff
operator|<
name|characters
operator|.
name|length
condition|)
block|{
name|boolean
name|last
init|=
operator|(
name|coff
operator|==
operator|(
name|characters
operator|.
name|length
operator|-
literal|4
operator|)
operator|)
decl_stmt|;
name|int
name|curr
init|=
operator|(
operator|(
name|value
argument_list|(
name|characters
index|[
name|coff
index|]
argument_list|,
name|last
argument_list|)
operator|<<
literal|0x12
operator|)
operator||
operator|(
name|value
argument_list|(
name|characters
index|[
name|coff
operator|+
literal|1
index|]
argument_list|,
name|last
argument_list|)
operator|<<
literal|0x0c
operator|)
operator||
operator|(
name|value
argument_list|(
name|characters
index|[
name|coff
operator|+
literal|2
index|]
argument_list|,
name|last
argument_list|)
operator|<<
literal|0x06
operator|)
operator||
operator|(
name|value
argument_list|(
name|characters
index|[
name|coff
operator|+
literal|3
index|]
argument_list|,
name|last
argument_list|)
operator|)
operator|)
decl_stmt|;
name|bytes
index|[
name|boff
operator|+
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
operator|(
name|curr
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bytes
index|[
name|boff
operator|+
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
operator|(
name|curr
operator|>>
literal|0x08
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bytes
index|[
name|boff
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
operator|(
name|curr
operator|>>
literal|0x10
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|coff
operator|+=
literal|4
expr_stmt|;
name|boff
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* Get the real decoded string length, checking out the trailing '=' */
if|if
condition|(
name|characters
index|[
name|coff
operator|-
literal|1
index|]
operator|==
literal|'='
condition|)
name|boff
operator|--
expr_stmt|;
if|if
condition|(
name|characters
index|[
name|coff
operator|-
literal|2
index|]
operator|==
literal|'='
condition|)
name|boff
operator|--
expr_stmt|;
comment|/* All done */
return|return
operator|(
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|boff
argument_list|,
name|encoding
argument_list|)
operator|)
return|;
block|}
comment|/**      *<p>Decode the specified base 64 string using the default encoding.</p>      */
specifier|public
specifier|static
specifier|final
name|String
name|base64Decode
parameter_list|(
name|String
name|string
parameter_list|)
block|{
try|try
block|{
return|return
operator|(
name|base64Decode
argument_list|(
name|string
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
operator|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/* ====================================================================== */
comment|/**<p>Retrieve the offset of a character in the base 64 alphabet.</p> */
specifier|private
specifier|static
specifier|final
name|int
name|value
parameter_list|(
name|char
name|character
parameter_list|,
name|boolean
name|last
parameter_list|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|64
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|ALPHABET
index|[
name|x
index|]
operator|==
name|character
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|last
operator|&&
operator|(
name|character
operator|==
name|ALPHABET
index|[
literal|65
index|]
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
specifier|final
name|String
name|message
init|=
literal|"Character \""
operator|+
name|character
operator|+
literal|"\" invalid"
decl_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

