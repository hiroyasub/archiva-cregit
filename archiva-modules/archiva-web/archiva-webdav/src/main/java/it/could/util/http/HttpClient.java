begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* ========================================================================== *  *         Copyright (C) 2004-2006, Pier Fumagalli<http://could.it/>         *  *                            All rights reserved.                            *  * ========================================================================== *  *                                                                            *  * Licensed under the  Apache License, Version 2.0  (the "License").  You may *  * not use this file except in compliance with the License.  You may obtain a *  * copy of the License at<http://www.apache.org/licenses/LICENSE-2.0>.       *  *                                                                            *  * Unless  required  by applicable  law or  agreed  to  in writing,  software *  * distributed under the License is distributed on an  "AS IS" BASIS, WITHOUT *  * WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied.  See the *  * License for the  specific language  governing permissions  and limitations *  * under the License.                                                         *  *                                                                            *  * ========================================================================== */
end_comment

begin_package
package|package
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|http
package|;
end_package

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
operator|.
name|EncodingTools
import|;
end_import

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|location
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  *<p>A class implementing an extremely simple HTTP 1.0 connector with  * basic authentication support.</p>  *  * @author<a href="http://could.it/">Pier Fumagalli</a>  */
end_comment

begin_class
specifier|public
class|class
name|HttpClient
block|{
comment|/**<p>The default HTTP method to use.</p> */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_METHOD
init|=
literal|"GET"
decl_stmt|;
comment|/* ====================================================================== */
comment|/**<p>The byte sequence CR LF (the end of the request).</p> */
specifier|private
specifier|static
specifier|final
name|byte
name|CRLF
index|[]
init|=
block|{
literal|0x0d
block|,
literal|0x0a
block|}
decl_stmt|;
comment|/**<p>The byte sequence for " HTTP/1.0\r\n" (the request signature).</p> */
specifier|private
specifier|static
specifier|final
name|byte
name|HTTP
index|[]
init|=
block|{
literal|0x20
block|,
literal|0x48
block|,
literal|0x54
block|,
literal|0x54
block|,
literal|0x50
block|,
literal|0x2f
block|,
literal|0x31
block|,
literal|0x2e
block|,
literal|0x30
block|,
literal|0x0d
block|,
literal|0x0a
block|}
decl_stmt|;
comment|/* ====================================================================== */
comment|/**<p>The buffer used to parse lines in the response.</p> */
specifier|private
specifier|final
name|byte
name|buffer
index|[]
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
comment|/**<p>The map of the current request headers.</p> */
specifier|private
specifier|final
name|Map
name|requestHeaders
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/**<p>The map of the current response headers.</p> */
specifier|private
specifier|final
name|Map
name|responseHeaders
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/* ====================================================================== */
comment|/**<p>The {@link Location} pointing to the current request.</p> */
specifier|private
name|Location
name|location
decl_stmt|;
comment|/**<p>The status of the current request.</p> */
specifier|private
name|Status
name|status
init|=
literal|null
decl_stmt|;
comment|/**<p>An array of acceptable statuses to verify upon connection.</p> */
specifier|private
name|int
name|acceptable
index|[]
init|=
literal|null
decl_stmt|;
comment|/* ====================================================================== */
comment|/**<p>The limited input stream associated with this request.</p> */
specifier|private
name|Input
name|xinput
init|=
literal|null
decl_stmt|;
comment|/**<p>The limited output stream associated with this request.</p> */
specifier|private
name|Output
name|xoutput
init|=
literal|null
decl_stmt|;
comment|/**<p>The socket associated with this request.</p> */
specifier|private
name|Socket
name|xsocket
init|=
literal|null
decl_stmt|;
comment|/* ====================================================================== */
comment|/**      *<p>Create a new {@link HttpClient} instance associated with the      * specified location in string format.</p>      *       * @throws MalformedURLException if the location couldn't be parsed.      */
specifier|public
name|HttpClient
parameter_list|(
name|String
name|location
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|this
operator|.
name|location
operator|=
name|Location
operator|.
name|parse
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>Create a new {@link HttpClient} instance associated with the      * specified location in string format.</p>      *       * @throws MalformedURLException if the location couldn't be parsed.      */
specifier|public
name|HttpClient
parameter_list|(
name|String
name|location
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|MalformedURLException
throws|,
name|UnsupportedEncodingException
block|{
name|this
operator|.
name|location
operator|=
name|Location
operator|.
name|parse
argument_list|(
name|location
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>Create a new {@link HttpClient} instance associated with the      * specified {@link Location}.</p>      */
specifier|public
name|HttpClient
parameter_list|(
name|Location
name|location
parameter_list|)
block|{
if|if
condition|(
name|location
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null location"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|location
operator|.
name|isAbsolute
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Relative location supplied"
argument_list|)
throw|;
if|if
condition|(
operator|!
literal|"http"
operator|.
name|equals
argument_list|(
name|location
operator|.
name|getSchemes
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Scheme is not HTTP"
argument_list|)
throw|;
block|}
name|this
operator|.
name|location
operator|=
name|location
expr_stmt|;
block|}
comment|/* ====================================================================== */
comment|/* CONNECTION VERIFICATION METHODS                                        */
comment|/* ====================================================================== */
comment|/**      *<p>Set an HTTP response status code considered to be acceptable when      * verifying the connection.</p>      */
specifier|public
name|HttpClient
name|setAcceptableStatus
parameter_list|(
name|int
name|status
parameter_list|)
block|{
return|return
name|this
operator|.
name|setAcceptableStatuses
argument_list|(
operator|new
name|int
index|[]
block|{
name|status
block|}
argument_list|)
return|;
block|}
comment|/**      *<p>Set an array of HTTP response status codes considered to be acceptable      * when verifying the connection.</p>      *       *<p>If the array is<b>null</b> status code checking is disabled.</p>      */
specifier|public
name|HttpClient
name|setAcceptableStatuses
parameter_list|(
name|int
name|statuses
index|[]
parameter_list|)
block|{
if|if
condition|(
name|statuses
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|acceptable
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|statuses
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
specifier|final
name|int
name|status
init|=
name|statuses
index|[
name|x
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|100
operator|)
operator|||
operator|(
name|status
operator|>
literal|599
operator|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong status "
operator|+
name|status
argument_list|)
throw|;
block|}
name|this
operator|.
name|acceptable
operator|=
name|statuses
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/* ====================================================================== */
comment|/* CONNECTION METHODS                                                     */
comment|/* ====================================================================== */
comment|/**      *<p>Connect to the {@link Location} specified at construction using the      * default method<code>GET</code>.</p>      *       *<p>This is equivalent to {@link #connect(boolean) connect(true)}.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|DEFAULT_METHOD
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Connect to the {@link Location} specified at construction using the      * default method<code>GET</code> allowing for a specified amount of      * content to be written into the request.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|(
name|long
name|contentLength
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|DEFAULT_METHOD
argument_list|,
literal|false
argument_list|,
name|contentLength
argument_list|)
return|;
block|}
comment|/**      *<p>Connect to the {@link Location} specified at construction using the      * default method<code>GET</code> and optionally following redirects.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|(
name|boolean
name|followRedirects
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|DEFAULT_METHOD
argument_list|,
name|followRedirects
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Connect to the {@link Location} specified at construction with the      * specified method.</p>      *       *<p>This is equivalent to {@link #connect(String,boolean)      * connect(method, true)}.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|(
name|String
name|method
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|method
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Connect to the {@link Location} specified at construction with the      * specified method allowing for a specified amount of content to be      * written into the request.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|(
name|String
name|method
parameter_list|,
name|long
name|contentLength
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|method
argument_list|,
literal|false
argument_list|,
name|contentLength
argument_list|)
return|;
block|}
comment|/**      *<p>Connect to the {@link Location} specified at construction with the      * specified method and optionally following redirects.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|connect
parameter_list|(
name|String
name|method
parameter_list|,
name|boolean
name|followRedirects
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connect
argument_list|(
name|method
argument_list|,
name|followRedirects
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Disconnect from the remote endpoint and terminate the request.</p>      *       *<p>Note that request and response headers, the resultin status and      * acceptable statuses are<b>not</b> cleared by this method.</p>      *       * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|disconnect
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|disconnect
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      *<p>Disconnect from the remote endpoint and terminate the request.</p>      *      * @param reset whether to reset all headers, status and acceptable response      *              status codes or not.      * @return this {@link HttpClient} instance.      * @throws IOException if an I/O or a network error occurred.      */
specifier|public
name|HttpClient
name|disconnect
parameter_list|(
name|boolean
name|reset
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Socket
name|socket
init|=
name|this
operator|.
name|xsocket
decl_stmt|;
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
try|try
block|{
comment|/* Make sure that we mark this instance as being closed */
name|this
operator|.
name|xsocket
operator|=
literal|null
expr_stmt|;
comment|/* Close the input stream if necessary */
if|if
condition|(
name|this
operator|.
name|xinput
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|xinput
operator|.
name|closed
condition|)
name|this
operator|.
name|xinput
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|xinput
operator|=
literal|null
expr_stmt|;
block|}
comment|/* Close the output stream if necessary */
if|if
condition|(
name|this
operator|.
name|xoutput
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|xoutput
operator|.
name|closed
condition|)
name|this
operator|.
name|xoutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|xoutput
operator|=
literal|null
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|/* Ensure that the socket is closed */
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reset
condition|)
block|{
name|this
operator|.
name|requestHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|responseHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|status
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|acceptable
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/* ====================================================================== */
comment|/* INTERNAL CONNECTION HANDLER                                            */
comment|/* ====================================================================== */
comment|/**      *<p>Internal method actually connecting to the remote HTTP server.</p>      */
specifier|private
name|HttpClient
name|connect
parameter_list|(
name|String
name|method
parameter_list|,
name|boolean
name|redirect
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* Check if (by any chance) we have been connected already */
if|if
condition|(
name|this
operator|.
name|xsocket
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Already connected"
argument_list|)
throw|;
comment|/* Check for both follow redirects and content length */
if|if
condition|(
name|length
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Negative length"
argument_list|)
throw|;
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
name|redirect
condition|)
throw|throw
operator|new
name|InternalError
argument_list|(
literal|"Can't follow redirects and write request"
argument_list|)
throw|;
comment|/* Verify any authentication token */
specifier|final
name|String
name|userinfo
init|=
name|this
operator|.
name|location
operator|.
name|getAuthority
argument_list|()
operator|.
name|getUserInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|userinfo
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|encoded
init|=
name|EncodingTools
operator|.
name|base64Encode
argument_list|(
name|userinfo
argument_list|)
decl_stmt|;
name|this
operator|.
name|addRequestHeader
argument_list|(
literal|"Authorization"
argument_list|,
literal|"Basic "
operator|+
name|encoded
argument_list|)
expr_stmt|;
block|}
comment|/* All methods in HTTP are upper case */
name|method
operator|=
name|method
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
comment|/* Make sure we close the connection at the end of the request */
name|this
operator|.
name|addRequestHeader
argument_list|(
literal|"Connection"
argument_list|,
literal|"close"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* The content length of the request is forced to be valid */
name|this
operator|.
name|addRequestHeader
argument_list|(
literal|"Content-Length"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|length
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* Enter in a loop for redirections */
name|int
name|redirs
init|=
literal|20
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|/* If we have been redirected too many times, fail */
if|if
condition|(
operator|(
operator|--
name|redirs
operator|)
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too many redirections"
argument_list|)
throw|;
comment|/* Get the authority, once and for all */
specifier|final
name|Location
operator|.
name|Authority
name|auth
init|=
name|this
operator|.
name|location
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
comment|/* Prepare a normalized host header */
specifier|final
name|String
name|host
init|=
name|auth
operator|.
name|getHost
argument_list|()
decl_stmt|;
specifier|final
name|int
name|port
init|=
name|auth
operator|.
name|getPort
argument_list|()
operator|<
literal|0
condition|?
literal|80
else|:
name|auth
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|addRequestHeader
argument_list|(
literal|"Host"
argument_list|,
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* Connect to the remote endpoint */
specifier|final
name|Socket
name|sock
init|=
operator|new
name|Socket
argument_list|(
name|auth
operator|.
name|getHost
argument_list|()
argument_list|,
name|port
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|in
init|=
name|sock
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
specifier|final
name|OutputStream
name|out
init|=
name|sock
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
comment|/* Write the request line */
name|out
operator|.
name|write
argument_list|(
operator|(
name|method
operator|+
literal|" "
operator|)
operator|.
name|getBytes
argument_list|(
literal|"US-ASCII"
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|this
operator|.
name|location
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"US-ASCII"
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|HTTP
argument_list|)
expr_stmt|;
comment|/* SPACE HTTP/1.0 CR LF */
comment|/* Write all the headers */
specifier|final
name|Iterator
name|headers
init|=
name|this
operator|.
name|requestHeaders
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|headers
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|RequestHeader
name|header
init|=
operator|(
name|RequestHeader
operator|)
name|headers
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
name|values
init|=
name|header
operator|.
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|header
operator|.
name|name
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|values
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write the final CRLF, read the status and the headers */
name|out
operator|.
name|write
argument_list|(
name|CRLF
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|/* Return now if we have to write content */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|xsocket
operator|=
name|sock
expr_stmt|;
name|this
operator|.
name|xoutput
operator|=
operator|new
name|Output
argument_list|(
name|this
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|xinput
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
name|this
operator|.
name|readStatusLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|readHeaders
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* If we have to follow redirects, let's inspect the response */
specifier|final
name|int
name|code
init|=
name|this
operator|.
name|status
operator|.
name|status
decl_stmt|;
if|if
condition|(
name|redirect
operator|&&
operator|(
operator|(
name|code
operator|==
literal|301
operator|)
operator|||
operator|(
name|code
operator|==
literal|302
operator|)
operator|||
operator|(
name|code
operator|==
literal|307
operator|)
operator|)
condition|)
block|{
specifier|final
name|String
name|location
init|=
name|this
operator|.
name|getResponseHeader
argument_list|(
literal|"Location"
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|sock
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|location
operator|=
name|this
operator|.
name|location
operator|.
name|resolve
argument_list|(
name|location
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* No further redirections, so verify if the status code is ok */
name|this
operator|.
name|verify
argument_list|()
expr_stmt|;
comment|/* Evaluate the content length specified by the server */
specifier|final
name|String
name|len
init|=
name|this
operator|.
name|getResponseHeader
argument_list|(
literal|"Content-Length"
argument_list|)
decl_stmt|;
name|long
name|bytesLength
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|null
condition|)
try|try
block|{
name|bytesLength
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
comment|/* Swallow this, be liberal in what we accept */
block|}
comment|/* Return an output stream if the content length was not zero */
name|this
operator|.
name|xsocket
operator|=
name|sock
expr_stmt|;
name|this
operator|.
name|xoutput
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|xinput
operator|=
operator|new
name|Input
argument_list|(
name|this
argument_list|,
name|in
argument_list|,
name|bytesLength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
specifier|private
name|void
name|verify
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* No further redirections, sov erify if the status code is ok */
if|if
condition|(
name|this
operator|.
name|acceptable
operator|!=
literal|null
condition|)
block|{
name|boolean
name|accepted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|this
operator|.
name|acceptable
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|status
operator|.
name|status
operator|!=
name|this
operator|.
name|acceptable
index|[
name|x
index|]
condition|)
continue|continue;
name|accepted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|accepted
condition|)
block|{
name|this
operator|.
name|disconnect
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Connection to "
operator|+
name|this
operator|.
name|location
operator|+
literal|" returned unacceptable status "
operator|+
name|this
operator|.
name|status
operator|.
name|status
operator|+
literal|" ("
operator|+
name|this
operator|.
name|status
operator|.
name|message
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/* ====================================================================== */
comment|/* INPUT / OUTPUT METHODS                                                 */
comment|/* ====================================================================== */
comment|/**      *<p>Return an {@link InputStream} where the content of the HTTP response      * can be read from.</p>      *       * @throws IllegalStateException if this instance is not connected yet, or      *                               the request body was not fully written yet.      */
specifier|public
name|InputStream
name|getResponseStream
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|this
operator|.
name|xsocket
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Connection not available"
argument_list|)
throw|;
if|if
condition|(
operator|(
name|this
operator|.
name|xoutput
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|this
operator|.
name|xoutput
operator|.
name|remaining
operator|!=
literal|0
operator|)
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Request body not fully written"
argument_list|)
throw|;
return|return
name|this
operator|.
name|xinput
return|;
block|}
comment|/**      *<p>Return an {@link OutputStream} where the content of the HTTP request      * can be written to.</p>      *      * @throws IllegalStateException if this instance is not connected yet or if      *                               upon connection the size of the request was      *                               not specifed or<b>zero</b>.      */
specifier|public
name|OutputStream
name|getRequestStream
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|this
operator|.
name|xsocket
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Connection not available"
argument_list|)
throw|;
if|if
condition|(
name|this
operator|.
name|xoutput
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No request body to write to"
argument_list|)
throw|;
return|return
name|this
operator|.
name|xoutput
return|;
block|}
comment|/* ====================================================================== */
comment|/* REQUEST AND RESPONSE METHODS                                           */
comment|/* ====================================================================== */
comment|/**      *<p>Return the {@link Location} of this connection.</p>      *       *<p>This might be different from the {@link Location} specified at      * construction time if upon connecting HTTP redirections were followed.</p>      */
specifier|public
name|Location
name|getLocation
parameter_list|()
block|{
return|return
name|this
operator|.
name|location
return|;
block|}
comment|/**      *<p>Add a new header that will be sent with the HTTP request.</p>      *       *<p>This method will remove any header value previously associated with      * the specified name, in other words this method is equivalent to      * {@link #addRequestHeader(String, String, boolean)      *  addRequestHeader(name, value, false)}.</p>      *       * @param name the name of the request header to add.      * @param value the value of the request header to add.      * @return this {@link HttpClient} instance.      * @throws NullPointerException the name or value were<b>null</b>.      */
specifier|public
name|HttpClient
name|addRequestHeader
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|this
operator|.
name|addRequestHeader
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      *<p>Add a new header that will be sent with the HTTP request.</p>      *       * @param name the name of the request header to add.      * @param value the value of the request header to add.      * @param appendValue if the current value should be appended, or in other      *                    words, that two headers with the same can coexist.       * @return this {@link HttpClient} instance.      * @throws NullPointerException the name or value were<b>null</b>.      */
specifier|public
name|HttpClient
name|addRequestHeader
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|boolean
name|appendValue
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
try|try
block|{
name|RequestHeader
name|header
decl_stmt|;
if|if
condition|(
name|appendValue
condition|)
block|{
name|header
operator|=
operator|(
name|RequestHeader
operator|)
name|this
operator|.
name|requestHeaders
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
literal|null
condition|)
block|{
name|header
operator|=
operator|new
name|RequestHeader
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestHeaders
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|header
operator|=
operator|new
name|RequestHeader
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestHeaders
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
name|header
operator|.
name|values
operator|.
name|add
argument_list|(
operator|(
name|value
operator|+
literal|"\r\n"
operator|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
name|Error
name|error
init|=
operator|new
name|InternalError
argument_list|(
literal|"Standard encoding not supported"
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Remove the named header from the current HTTP request.</p>      *       * @param name the name of the request header to add.      * @return this {@link HttpClient} instance.      * @throws NullPointerException the name was<b>null</b>.      */
specifier|public
name|HttpClient
name|removeRequestHeader
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|this
operator|.
name|requestHeaders
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      *<p>Remove all headers from the current HTTP request.</p>      *       * @return this {@link HttpClient} instance.      */
specifier|public
name|HttpClient
name|removeRequestHeaders
parameter_list|()
block|{
name|this
operator|.
name|requestHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      *<p>Return the first value for the specified response header.</p>      *      * @param name the name of the header whose value needs to be returned.      * @return a {@link String} or<b>null</b> if no such header exists.      */
specifier|public
name|String
name|getResponseHeader
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|ResponseHeader
name|header
init|=
operator|(
name|ResponseHeader
operator|)
name|this
operator|.
name|responseHeaders
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|(
name|String
operator|)
name|header
operator|.
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Return all the values for the specified response header.</p>      *      * @param name the name of the header whose values needs to be returned.      * @return a {@link List} or<b>null</b> if no such header exists.      */
specifier|public
name|List
name|getResponseHeaderValues
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|ResponseHeader
name|header
init|=
operator|(
name|ResponseHeader
operator|)
name|this
operator|.
name|responseHeaders
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|header
operator|.
name|values
argument_list|)
return|;
block|}
comment|/**      *<p>Return an {@link Iterator} over all response header names.</p>      *      * @return a<b>non-null</b> {@link Iterator}.      */
specifier|public
name|Iterator
name|getResponseHeaderNames
parameter_list|()
block|{
specifier|final
name|Iterator
name|iterator
init|=
name|this
operator|.
name|responseHeaders
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Object
name|next
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ResponseHeader
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|name
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/**      *<p>Return the protocol returned by the remote HTTP server.</p>      *      * @return a<b>non-null</b> {@link String} like<code>HTTP/1.0</code>.      * @throws IllegalStateException if the connection was never connected.       */
specifier|public
name|String
name|getResponseProtocol
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|status
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
name|this
operator|.
name|status
operator|.
name|protocol
return|;
block|}
comment|/**      *<p>Return the status returned by the remote HTTP server.</p>      *      * @return a number representing the HTTP status of the response.      * @throws IllegalStateException if the connection was never connected.       */
specifier|public
name|int
name|getResponseStatus
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|status
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
name|this
operator|.
name|status
operator|.
name|status
return|;
block|}
comment|/**      *<p>Return the status message returned by the remote HTTP server.</p>      *      * @return a<b>non-null</b> {@link String} like<code>OK</code>.      * @throws IllegalStateException if the connection was never connected.       */
specifier|public
name|String
name|getResponseMessage
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|status
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
name|this
operator|.
name|status
operator|.
name|message
return|;
block|}
comment|/* ====================================================================== */
comment|/* PRIVATE METHODS TO USE WHEN CONNECTING                                 */
comment|/* ====================================================================== */
comment|/**      *<p>Read a single line of the HTTP response from the specified      * {@link InputStream} into a byte array (trailing CRLF are removed).</p>      */
specifier|private
name|byte
index|[]
name|readLine
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|b
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|b
operator|==
literal|0x0A
condition|)
break|break;
if|if
condition|(
name|x
operator|==
name|this
operator|.
name|buffer
operator|.
name|length
condition|)
break|break;
name|this
operator|.
name|buffer
index|[
name|x
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x
operator|>
literal|0
operator|)
operator|&&
operator|(
name|this
operator|.
name|buffer
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|0x0D
operator|)
condition|)
name|x
operator|--
expr_stmt|;
specifier|final
name|byte
name|array
index|[]
init|=
operator|new
name|byte
index|[
name|x
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|array
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
comment|/**      *<p>Read the status line from the specified {@link InputStream} and      * setup the {@link #status} field.</p>      */
specifier|private
name|void
name|readStatusLine
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* Prepare the different buffers required for parsing */
specifier|final
name|byte
name|line
index|[]
init|=
name|this
operator|.
name|readLine
argument_list|(
name|input
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|buff
index|[]
init|=
operator|new
name|byte
index|[
name|line
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|String
name|comp
index|[]
init|=
operator|new
name|String
index|[
literal|3
index|]
decl_stmt|;
name|int
name|lpos
init|=
literal|0
decl_stmt|;
name|int
name|bpos
init|=
literal|0
decl_stmt|;
name|int
name|cpos
init|=
literal|0
decl_stmt|;
name|boolean
name|spc
init|=
literal|true
decl_stmt|;
comment|/* Iterate every single byte in the line, splitting up components */
while|while
condition|(
name|lpos
operator|<
name|line
operator|.
name|length
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|line
index|[
name|lpos
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|spc
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|==
literal|0x09
operator|)
operator|||
operator|(
name|b
operator|==
literal|0x20
operator|)
condition|)
continue|continue;
name|buff
index|[
name|bpos
operator|++
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|cpos
operator|==
literal|2
condition|)
break|break;
else|else
name|spc
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|b
operator|==
literal|0x09
operator|)
operator|||
operator|(
name|b
operator|==
literal|0x20
operator|)
condition|)
block|{
name|comp
index|[
name|cpos
operator|++
index|]
operator|=
operator|new
name|String
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|bpos
argument_list|,
literal|"US-ASCII"
argument_list|)
expr_stmt|;
name|bpos
operator|=
literal|0
expr_stmt|;
name|spc
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|buff
index|[
name|bpos
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/*          * Copy remaining bytes out of the line buffer and ensure all          * components in the status line are not null;          */
while|while
condition|(
name|lpos
operator|<
name|line
operator|.
name|length
condition|)
name|buff
index|[
name|bpos
operator|++
index|]
operator|=
name|line
index|[
name|lpos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|bpos
operator|>
literal|0
condition|)
name|comp
index|[
name|cpos
operator|++
index|]
operator|=
operator|new
name|String
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|bpos
argument_list|,
literal|"US-ASCII"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
name|cpos
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
name|comp
index|[
name|x
index|]
operator|=
literal|""
expr_stmt|;
comment|/* Create the status object */
name|this
operator|.
name|status
operator|=
operator|new
name|Status
argument_list|(
name|comp
index|[
literal|0
index|]
argument_list|,
name|comp
index|[
literal|1
index|]
argument_list|,
name|comp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>Read all the response headers from the specified {@link InputStream}      * and setup the {@link #responseHeaders} field.</p>      */
specifier|private
name|void
name|readHeaders
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* Clear out any previous header */
name|this
operator|.
name|responseHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|/* Process the input stream until we find an empty line */
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|byte
name|array
index|[]
init|=
name|this
operator|.
name|readLine
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|.
name|length
operator|==
literal|0
condition|)
break|break;
comment|/* Identify where the colon is in the header */
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|array
operator|.
name|length
condition|)
if|if
condition|(
name|array
index|[
operator|++
name|pos
index|]
operator|==
literal|0x03A
condition|)
break|break;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pos
operator|==
name|array
operator|.
name|length
operator|-
literal|1
condition|)
continue|continue;
comment|/* Prepare strings for name and value */
specifier|final
name|int
name|o
init|=
name|pos
operator|+
literal|1
decl_stmt|;
specifier|final
name|int
name|l
init|=
name|array
operator|.
name|length
operator|-
name|o
decl_stmt|;
specifier|final
name|String
name|name
init|=
operator|new
name|String
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|,
literal|"US-ASCII"
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|String
name|value
init|=
operator|new
name|String
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
name|l
argument_list|,
literal|"ISO-8859-1"
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Store the header value in a list for now */
specifier|final
name|String
name|key
init|=
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|ResponseHeader
name|hdr
init|=
operator|(
name|ResponseHeader
operator|)
name|this
operator|.
name|responseHeaders
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdr
operator|==
literal|null
condition|)
block|{
name|hdr
operator|=
operator|new
name|ResponseHeader
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|responseHeaders
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|.
name|values
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ====================================================================== */
comment|/* INTERNAL CLASS REPRESENTNG THE STATUS LINE AND AN ENCODED HEADER       */
comment|/* ====================================================================== */
comment|/**      *<p>A simple internal class representing a response status line.</p>      */
specifier|private
specifier|static
specifier|final
class|class
name|Status
block|{
comment|/**<p>The response protocol, like<code>HTTP/1.0</code> */
specifier|private
specifier|final
name|String
name|protocol
decl_stmt|;
comment|/**<p>The response status code, like<code>302</code> */
specifier|private
specifier|final
name|int
name|status
decl_stmt|;
comment|/**<p>The response message, like<code>Moved permanently</code> */
specifier|private
specifier|final
name|String
name|message
decl_stmt|;
comment|/**          *<p>Create a new {@link Status} verifying the supplied parameters.</p>          *           * @throws IOException if an error occurred verifying the parameters.          */
specifier|private
name|Status
parameter_list|(
name|String
name|protocol
parameter_list|,
name|String
name|status
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* Verify the protocol */
if|if
condition|(
literal|"HTTP/1.0"
operator|.
name|equals
argument_list|(
name|protocol
argument_list|)
operator|||
literal|"HTTP/1.1"
operator|.
name|equals
argument_list|(
name|protocol
argument_list|)
condition|)
block|{
name|this
operator|.
name|protocol
operator|=
name|protocol
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol \""
operator|+
name|protocol
operator|+
literal|"\""
argument_list|)
throw|;
block|}
comment|/* Verify the status */
try|try
block|{
name|this
operator|.
name|status
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|status
operator|<
literal|100
operator|)
operator|||
operator|(
name|this
operator|.
name|status
operator|>
literal|599
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid status \""
operator|+
name|status
operator|+
literal|"\""
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|error
init|=
literal|"Can't parse status \""
operator|+
name|status
operator|+
literal|"\""
decl_stmt|;
name|IOException
name|throwable
init|=
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|IOException
operator|)
name|throwable
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
comment|/* Decode the message */
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|message
argument_list|)
condition|)
name|this
operator|.
name|message
operator|=
literal|"No message"
expr_stmt|;
else|else
name|this
operator|.
name|message
operator|=
name|EncodingTools
operator|.
name|urlDecode
argument_list|(
name|message
argument_list|,
literal|"ISO-8859-1"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *<p>A simple internal class representing a request header.</p>      */
specifier|private
specifier|static
specifier|final
class|class
name|RequestHeader
block|{
comment|/**<p>The byte array of the header's name.</p> */
specifier|private
specifier|final
name|byte
name|name
index|[]
decl_stmt|;
comment|/**<p>A {@link List} of all the header's values.</p> */
specifier|private
specifier|final
name|List
name|values
decl_stmt|;
comment|/**<p>Create a new {@link RequestHeader} instance.</p> */
specifier|private
name|RequestHeader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|this
operator|.
name|name
operator|=
operator|(
name|name
operator|+
literal|": "
operator|)
operator|.
name|getBytes
argument_list|(
literal|"US-ASCII"
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *<p>A simple internal class representing a response header.</p>      */
specifier|private
specifier|static
specifier|final
class|class
name|ResponseHeader
block|{
comment|/**<p>The real name of the response header.</p> */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**<p>A {@link List} of all the header's values.</p> */
specifier|private
specifier|final
name|List
name|values
decl_stmt|;
comment|/**<p>Create a new {@link ResponseHeader} instance.</p> */
specifier|private
name|ResponseHeader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|values
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* ====================================================================== */
comment|/* LIMITED STREAMS                                                        */
comment|/* ====================================================================== */
comment|/**      *<p>A simple {@link OutputStream} writing at most the number of bytes      * specified at construction.</p>      */
specifier|private
specifier|static
specifier|final
class|class
name|Output
extends|extends
name|OutputStream
block|{
comment|/**<p>The {@link OutputStream} wrapped by this instance.</p> */
specifier|private
specifier|final
name|OutputStream
name|output
decl_stmt|;
comment|/**<p>The {@link InputStream} wrapped by this instance.</p> */
specifier|private
specifier|final
name|InputStream
name|input
decl_stmt|;
comment|/**<p>The {@link HttpClient} wrapped by this instance.</p> */
specifier|private
specifier|final
name|HttpClient
name|client
decl_stmt|;
comment|/**<p>The number of bytes yet to write.</p> */
specifier|private
name|long
name|remaining
decl_stmt|;
comment|/**<p>A flag indicating whether this instance was closed.</p> */
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|/**          *<p>Create a new {@link Output} instance with the specified limit          * of bytes to write.</p>          *           * @param output the {@link OutputStream} to wrap.          * @param remainig the maximum number of bytes to write.          */
specifier|private
name|Output
parameter_list|(
name|HttpClient
name|client
parameter_list|,
name|InputStream
name|input
parameter_list|,
name|OutputStream
name|output
parameter_list|,
name|long
name|remaining
parameter_list|)
block|{
if|if
condition|(
name|input
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|output
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|client
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|remaining
operator|=
name|remaining
expr_stmt|;
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|buf
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|buf
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|len
operator|>
name|this
operator|.
name|remaining
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too much data to write"
argument_list|)
throw|;
block|}
else|else
try|try
block|{
name|this
operator|.
name|output
operator|.
name|write
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|remaining
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too much data to write"
argument_list|)
throw|;
block|}
else|else
try|try
block|{
name|this
operator|.
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|remaining
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
return|return;
if|if
condition|(
name|this
operator|.
name|remaining
operator|>
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|this
operator|.
name|remaining
operator|+
literal|" bytes left to write"
argument_list|)
throw|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|/* Read the status and headers from the connection and verify */
name|this
operator|.
name|client
operator|.
name|readStatusLine
argument_list|(
name|this
operator|.
name|input
argument_list|)
expr_stmt|;
name|this
operator|.
name|client
operator|.
name|readHeaders
argument_list|(
name|this
operator|.
name|input
argument_list|)
expr_stmt|;
name|this
operator|.
name|client
operator|.
name|verify
argument_list|()
expr_stmt|;
comment|/* Evaluate the content length specified by the server */
specifier|final
name|String
name|slen
init|=
name|this
operator|.
name|client
operator|.
name|getResponseHeader
argument_list|(
literal|"Content-Length"
argument_list|)
decl_stmt|;
name|long
name|blen
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|null
condition|)
try|try
block|{
name|blen
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|slen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
comment|/* Swallow this, be liberal in what we accept */
block|}
comment|/* Return an output stream if the content length was not zero */
name|this
operator|.
name|client
operator|.
name|xoutput
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|client
operator|.
name|xinput
operator|=
operator|new
name|Input
argument_list|(
name|this
operator|.
name|client
argument_list|,
name|this
operator|.
name|input
argument_list|,
name|blen
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      *<p>A simple {@link InputStream} reading at most the number of bytes      * specified at construction.</p>      */
specifier|private
specifier|static
specifier|final
class|class
name|Input
extends|extends
name|InputStream
block|{
comment|/**<p>The {@link InputStream} wrapped by this instance.</p> */
specifier|private
specifier|final
name|InputStream
name|input
decl_stmt|;
comment|/**<p>The {@link HttpClient} wrapped by this instance.</p> */
specifier|private
specifier|final
name|HttpClient
name|client
decl_stmt|;
comment|/**<p>The number of bytes yet to write or -1 if unknown.</p> */
specifier|private
name|long
name|remaining
decl_stmt|;
comment|/**<p>A flag indicating whether this instance was closed.</p> */
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|/**          *<p>Create a new {@link Input} instance with the specified limit          * of bytes to read.</p>          *           * @param input the {@link InputStream} to wrap.          * @param remainig the maximum number of bytes to read or -1 if unknown.          */
specifier|private
name|Input
parameter_list|(
name|HttpClient
name|client
parameter_list|,
name|InputStream
name|input
parameter_list|,
name|long
name|remaining
parameter_list|)
block|{
if|if
condition|(
name|input
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|client
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|remaining
operator|=
name|remaining
operator|<
literal|0
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|remaining
expr_stmt|;
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
try|try
block|{
return|return
name|this
operator|.
name|input
operator|.
name|read
argument_list|()
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|remaining
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
name|buf
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
name|buf
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|remaining
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|len
operator|>
name|this
operator|.
name|remaining
condition|)
name|len
operator|=
operator|(
name|int
operator|)
name|this
operator|.
name|remaining
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
name|count
operator|=
name|this
operator|.
name|input
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|remaining
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|remaining
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n
operator|>
name|this
operator|.
name|remaining
condition|)
name|n
operator|=
name|this
operator|.
name|remaining
expr_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
name|count
operator|=
name|this
operator|.
name|input
operator|.
name|skip
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|remaining
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|remaining
operator|<
literal|1
condition|)
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
init|=
name|this
operator|.
name|input
operator|.
name|available
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|this
operator|.
name|remaining
condition|)
return|return
name|count
return|;
return|return
operator|(
name|int
operator|)
name|this
operator|.
name|remaining
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
return|return;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|this
operator|.
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|client
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readlimit
parameter_list|)
block|{
name|this
operator|.
name|input
operator|.
name|mark
argument_list|(
name|readlimit
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|input
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
name|this
operator|.
name|input
operator|.
name|markSupported
argument_list|()
return|;
block|}
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* ====================================================================== */
comment|/* UTILITY FETCHER                                                        */
comment|/* ====================================================================== */
comment|/**      *<p><b>Utility method:</b> fetch the location specified on the command      * line following redirects if necessary.</p>      *       *<p>The final location fetched (in case of redirections it might change)      * will be reported on the {@link System#err system error stream} alongside      * with any errors encountered while processing.</p>      */
specifier|public
specifier|static
specifier|final
name|void
name|main
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
try|try
block|{
specifier|final
name|HttpClient
name|c
init|=
operator|new
name|HttpClient
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|.
name|connect
argument_list|()
decl_stmt|;
specifier|final
name|InputStream
name|i
init|=
name|c
operator|.
name|getResponseStream
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|b
init|=
name|i
operator|.
name|read
argument_list|()
init|;
name|b
operator|>=
literal|0
condition|;
name|b
operator|=
name|i
operator|.
name|read
argument_list|()
control|)
name|System
operator|.
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|c
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|throwable
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

