begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* ========================================================================== *  *         Copyright (C) 2004-2006, Pier Fumagalli<http://could.it/>         *  *                            All rights reserved.                            *  * ========================================================================== *  *                                                                            *  * Licensed under the  Apache License, Version 2.0  (the "License").  You may *  * not use this file except in compliance with the License.  You may obtain a *  * copy of the License at<http://www.apache.org/licenses/LICENSE-2.0>.       *  *                                                                            *  * Unless  required  by applicable  law or  agreed  to  in writing,  software *  * distributed under the License is distributed on an  "AS IS" BASIS, WITHOUT *  * WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied.  See the *  * License for the  specific language  governing permissions  and limitations *  * under the License.                                                         *  *                                                                            *  * ========================================================================== */
end_comment

begin_package
package|package
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|location
package|;
end_package

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|StringTools
import|;
end_import

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
operator|.
name|Encodable
import|;
end_import

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
operator|.
name|EncodingTools
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  *<p>The {@link Parameters Parameters} class represents a never empty and  * immutable {@link List} of {@link Parameters.Parameter Parameter} instances,  * normally created parsing a query string.</p>  *  * @author<a href="http://could.it/">Pier Fumagalli</a>  */
end_comment

begin_class
specifier|public
class|class
name|Parameters
extends|extends
name|AbstractList
implements|implements
name|Encodable
block|{
comment|/**<p>The default delimiter for a {@link Parameters} instance.</p> */
specifier|public
specifier|static
specifier|final
name|char
name|DEFAULT_DELIMITER
init|=
literal|'&'
decl_stmt|;
comment|/**<p>All the {@link Parameter}s in order.</p> */
specifier|private
specifier|final
name|Parameter
name|parameters
index|[]
decl_stmt|;
comment|/**<p>The {@link Map} view over all parameters (names are keys).</p> */
specifier|private
specifier|final
name|Map
name|map
decl_stmt|;
comment|/**<p>The {@link Set} of all parameter names.</p> */
specifier|final
name|Set
name|names
decl_stmt|;
comment|/**<p>The character delimiting different parameters.</p> */
specifier|private
specifier|final
name|char
name|delimiter
decl_stmt|;
comment|/**<p>The encoded {@link String} representation of this.</p> */
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
comment|/**      *<p>Create a new {@link Parameters Parameters} instance from      * a {@link List} of {@link Parameters.Parameter Parameter} instances      * using the {@link #DEFAULT_DELIMITER default parameter delimiter}.</p>      *       * @throws NullPointerExceptoin if the {@link List} was<b>null</b>.      * @throws IllegalArgumentException if the {@link List} was empty.      * @throws ClassCastException if any of the elements in the {@link List} was      *                            not a {@link Parameters.Parameter Parameter}.      */
specifier|public
name|Parameters
parameter_list|(
name|List
name|parameters
parameter_list|)
block|{
name|this
argument_list|(
name|parameters
argument_list|,
name|DEFAULT_DELIMITER
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>Create a new {@link Parameters Parameters} instance from      * a {@link List} of {@link Parameters.Parameter Parameter} instances      * using the specified character as the parameters delimiter.</p>      *       * @throws NullPointerExceptoin if the {@link List} was<b>null</b>.      * @throws IllegalArgumentException if the {@link List} was empty.      * @throws ClassCastException if any of the elements in the {@link List} was      *                            not a {@link Parameters.Parameter Parameter}.      */
specifier|public
name|Parameters
parameter_list|(
name|List
name|parameters
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|parameters
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
specifier|final
name|Parameter
name|array
index|[]
init|=
operator|new
name|Parameter
index|[
name|parameters
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|Map
name|map
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|array
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
specifier|final
name|Parameter
name|parameter
init|=
operator|(
name|Parameter
operator|)
name|parameters
operator|.
name|get
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|final
name|String
name|key
init|=
name|parameter
operator|.
name|getName
argument_list|()
decl_stmt|;
name|List
name|values
init|=
operator|(
name|List
operator|)
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|add
argument_list|(
name|parameter
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|array
index|[
name|x
index|]
operator|=
name|parameter
expr_stmt|;
block|}
comment|/* Make all parameter value lists unmodifiable */
for|for
control|(
name|Iterator
name|iter
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|List
name|list
init|=
operator|(
name|List
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setValue
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store the current values */
name|this
operator|.
name|delimiter
operator|=
name|delimiter
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|names
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|parameters
operator|=
name|array
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|EncodingTools
operator|.
name|toString
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/* ====================================================================== */
comment|/* STATIC CONSTRUCTION METHODS                                            */
comment|/* ====================================================================== */
comment|/**      *<p>Utility method to create a new {@link Parameters} instance from a      * {@link List} of {@link Parameters.Parameter Parameter} instances.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified {@link List} was<b>null</b>, empty      *         or did not contain any {@link Parameters.Parameter Parameter}.      * @throws ClassCastException if any of the elements in the {@link List} was      *                            not a {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|create
parameter_list|(
name|List
name|parameters
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|parameters
argument_list|,
name|DEFAULT_DELIMITER
argument_list|)
return|;
block|}
comment|/**      *<p>Utility method to create a new {@link Parameters} instance from a      * {@link List} of {@link Parameters.Parameter Parameter} instances.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified {@link List} was<b>null</b>, empty      *         or did not contain any {@link Parameters.Parameter Parameter}.      * @throws ClassCastException if any of the elements in the {@link List} was      *                            not a {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|create
parameter_list|(
name|List
name|parameters
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|parameters
operator|==
literal|null
condition|)
return|return
literal|null
return|;
specifier|final
name|List
name|dedupes
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|parameters
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|next
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|dedupes
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
name|dedupes
operator|.
name|add
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dedupes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Parameters
argument_list|(
name|dedupes
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
comment|/**      *<p>Parse the specified parameters {@link String} into a      * {@link Parameters} instance using the {@link #DEFAULT_DELIMITER default      * parameter delimiter}.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified string was<b>null</b>, empty or      *         did not contain any {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
name|parameters
parameter_list|)
block|{
try|try
block|{
return|return
name|parse
argument_list|(
name|parameters
argument_list|,
name|DEFAULT_DELIMITER
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Parse the specified parameters {@link String} into a      * {@link Parameters} instance using the specified character as the      * parameters delimiter.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified string was<b>null</b>, empty or      *         did not contain any {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
name|parameters
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
try|try
block|{
return|return
name|parse
argument_list|(
name|parameters
argument_list|,
name|delimiter
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Parse the specified parameters {@link String} into a      * {@link Parameters} instance using the {@link #DEFAULT_DELIMITER default      * parameter delimiter}.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified string was<b>null</b>, empty or      *         did not contain any {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
name|parameters
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
name|parse
argument_list|(
name|parameters
argument_list|,
name|DEFAULT_DELIMITER
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/**      *<p>Parse the specified parameters {@link String} into a      * {@link Parameters} instance using the specified character as the      * parameters delimiter.</p>      *      * @return a<b>non-null</b> and not empty {@link Parameters} instance or      *<b>null</b> if the specified string was<b>null</b>, empty or      *         did not contain any {@link Parameters.Parameter Parameter}.      */
specifier|public
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
name|parameters
parameter_list|,
name|char
name|delimiter
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|parameters
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|parameters
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
specifier|final
name|String
name|split
index|[]
init|=
name|StringTools
operator|.
name|splitAll
argument_list|(
name|parameters
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
specifier|final
name|List
name|list
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|split
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|split
index|[
name|x
index|]
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|split
index|[
name|x
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Parameter
name|parameter
init|=
name|Parameter
operator|.
name|parse
argument_list|(
name|split
index|[
name|x
index|]
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|parameter
operator|!=
literal|null
condition|)
name|list
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Parameters
argument_list|(
name|list
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
comment|/* ====================================================================== */
comment|/* PUBLIC EXPOSED METHODS                                                 */
comment|/* ====================================================================== */
comment|/**      *<p>Return the number of {@link Parameters.Parameter Parameter}s      * contained by this instance.</p>      */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|parameters
operator|.
name|length
return|;
block|}
comment|/**      *<p>Return the {@link Parameters.Parameter Parameter} stored by this\      * instance at the specified index.</p>      */
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|this
operator|.
name|parameters
index|[
name|index
index|]
return|;
block|}
comment|/**      *<p>Return an immutable {@link Set} of {@link String}s containing all      * known {@link Parameters.Parameter Parameter}      * {@link Parameters.Parameter#getName() names}.</p>      */
specifier|public
name|Set
name|getNames
parameter_list|()
block|{
return|return
name|this
operator|.
name|names
return|;
block|}
comment|/**      *<p>Return the first {@link String} value associated with the      * specified parameter name, or<b>null</b>.</p>       */
specifier|public
name|String
name|getValue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|List
name|values
init|=
operator|(
name|List
operator|)
name|this
operator|.
name|map
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|values
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|String
operator|)
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      *<p>Return an immutable {@link List} of all {@link String} values      * associated with the specified parameter name, or<b>null</b>.</p>       */
specifier|public
name|List
name|getValues
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
operator|(
name|List
operator|)
name|this
operator|.
name|map
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/* ====================================================================== */
comment|/* OBJECT METHODS                                                         */
comment|/* ====================================================================== */
comment|/**      *<p>Return the URL-encoded {@link String} representation of this      * {@link Parameters Parameters} instance.</p>      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
return|;
block|}
comment|/**      *<p>Return the URL-encoded {@link String} representation of this      * {@link Parameters Parameters} instance using the specified      * character encoding.</p>      */
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|this
operator|.
name|parameters
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|this
operator|.
name|delimiter
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|this
operator|.
name|parameters
index|[
name|x
index|]
operator|.
name|toString
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      *<p>Return the hash code value of this      * {@link Parameters Parameters} instance.</p>      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      *<p>Check if the specified {@link Object} is equal to this      * {@link Parameters Parameters} instance.</p>      *       *<p>The specified {@link Object} is considered equal to this one if      * it is<b>non-null</b>, it is a {@link Parameters Parameters}      * instance, and its {@link #toString() string representation} equals      * this one's.</p>      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
operator|(
name|object
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|object
operator|instanceof
name|Parameters
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|string
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Parameters
operator|)
name|object
operator|)
operator|.
name|string
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/* ====================================================================== */
comment|/* PUBLIC INNER CLASSES                                                   */
comment|/* ====================================================================== */
comment|/**      *<p>The {@link Parameters.Parameter Parameter} class represents a single      * parameter either parsed from a query string or a path element.</p>      *       * @author<a href="http://could.it/">Pier Fumagalli</a>      */
specifier|public
specifier|static
class|class
name|Parameter
implements|implements
name|Encodable
block|{
comment|/**<p>The name of the parameter (decoded).</p> */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**<p>The value of the parameter (decoded).</p> */
specifier|private
specifier|final
name|String
name|value
decl_stmt|;
comment|/**<p>The encoded {@link String} representation of this.</p> */
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
comment|/**          *<p>Create a new {@link Parameters.Parameter Parameter} given an          * encoded parameter name and value.</p>          *           * @throws NullPointerException if the name was<b>null</b>.          * @throws IllegalArgumentException if the name was an empty string.          */
specifier|public
name|Parameter
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|EncodingTools
operator|.
name|toString
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/* ================================================================== */
comment|/* STATIC CONSTRUCTION METHODS                                        */
comment|/* ================================================================== */
comment|/**          *<p>Parse the specified parameters {@link String} into a          * {@link Parameters.Parameter} instance.</p>          *          * @return a<b>non-null</b> and not empty {@link Parameters.Parameter}          *         instance or<b>null</b> if the specified string was          *<b>null</b> or empty.          */
specifier|public
specifier|static
name|Parameter
name|parse
parameter_list|(
name|String
name|parameter
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
try|try
block|{
return|return
name|parse
argument_list|(
name|parameter
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**          *<p>Parse the specified parameters {@link String} into a          * {@link Parameters.Parameter} instance.</p>          *          * @return a<b>non-null</b> and not empty {@link Parameters.Parameter}          *         instance or<b>null</b> if the specified string was          *<b>null</b> or empty.          */
specifier|public
specifier|static
name|Parameter
name|parse
parameter_list|(
name|String
name|parameter
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|parameter
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
name|String
name|split
index|[]
init|=
name|StringTools
operator|.
name|splitOnce
argument_list|(
name|parameter
argument_list|,
literal|'='
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
index|[
literal|0
index|]
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Parameter
argument_list|(
name|split
index|[
literal|0
index|]
argument_list|,
name|split
index|[
literal|1
index|]
argument_list|)
return|;
block|}
comment|/* ================================================================== */
comment|/* PUBLIC EXPOSED METHODS                                             */
comment|/* ================================================================== */
comment|/**          *<p>Return the URL-decoded name of this          * {@link Parameters.Parameter Parameter} instance.</p>          */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/**          *<p>Return the URL-decoded value of this          * {@link Parameters.Parameter Parameter} instance.</p>          */
specifier|public
name|String
name|getValue
parameter_list|()
block|{
return|return
name|this
operator|.
name|value
return|;
block|}
comment|/* ================================================================== */
comment|/* OBJECT METHODS                                                     */
comment|/* ================================================================== */
comment|/**          *<p>Return the URL-encoded {@link String} representation of this          * {@link Parameters.Parameter Parameter} instance.</p>          */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
return|;
block|}
comment|/**          *<p>Return the URL-encoded {@link String} representation of this          * {@link Parameters.Parameter Parameter} instance using the specified          * character encoding.</p>          */
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|this
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|EncodingTools
operator|.
name|urlEncode
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|encoding
argument_list|)
operator|+
literal|"="
operator|+
name|EncodingTools
operator|.
name|urlEncode
argument_list|(
name|this
operator|.
name|value
argument_list|,
name|encoding
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|EncodingTools
operator|.
name|urlEncode
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|encoding
argument_list|)
return|;
block|}
block|}
comment|/**          *<p>Return the hash code value for this          * {@link Parameters.Parameter Parameter} instance.</p>          */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**          *<p>Check if the specified {@link Object} is equal to this          * {@link Parameters.Parameter Parameter} instance.</p>          *           *<p>The specified {@link Object} is considered equal to this one if          * it is<b>non-null</b>, it is a {@link Parameters.Parameter Parameter}          * instance, and its {@link #toString() string representation} equals          * this one's.</p>          */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
operator|(
name|object
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|object
operator|instanceof
name|Parameter
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|string
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Parameter
operator|)
name|object
operator|)
operator|.
name|string
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

