begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* ========================================================================== *  *         Copyright (C) 2004-2006, Pier Fumagalli<http://could.it/>         *  *                            All rights reserved.                            *  * ========================================================================== *  *                                                                            *  * Licensed under the  Apache License, Version 2.0  (the "License").  You may *  * not use this file except in compliance with the License.  You may obtain a *  * copy of the License at<http://www.apache.org/licenses/LICENSE-2.0>.       *  *                                                                            *  * Unless  required  by applicable  law or  agreed  to  in writing,  software *  * distributed under the License is distributed on an  "AS IS" BASIS, WITHOUT *  * WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied.  See the *  * License for the  specific language  governing permissions  and limitations *  * under the License.                                                         *  *                                                                            *  * ========================================================================== */
end_comment

begin_package
package|package
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|location
package|;
end_package

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|StringTools
import|;
end_import

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
operator|.
name|Encodable
import|;
end_import

begin_import
import|import
name|it
operator|.
name|could
operator|.
name|util
operator|.
name|encoding
operator|.
name|EncodingTools
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/**  *<p>The {@link Path Path} class is an ordered collection of  * {@link Path.Element Element} instances representing a path  * structure.</p>  *  * @author<a href="http://could.it/">Pier Fumagalli</a>  */
end_comment

begin_class
specifier|public
class|class
name|Path
extends|extends
name|AbstractList
implements|implements
name|Encodable
block|{
comment|/**<p>The array of {@link Path.Element Element}s.</p> */
specifier|private
specifier|final
name|Element
name|paths
index|[]
decl_stmt|;
comment|/**<p>The current {@link Parameters} instance or<b>null</b>.</p> */
specifier|private
specifier|final
name|Parameters
name|parameters
decl_stmt|;
comment|/**<p>A flag indicating whether this path is absolute or not.</p> */
specifier|private
specifier|final
name|boolean
name|absolute
decl_stmt|;
comment|/**<p>A flag indicating if this path is a collection or not.</p> */
specifier|private
specifier|final
name|boolean
name|collection
decl_stmt|;
comment|/**<p>The {@link String} representation of this (encoded).</p> */
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
comment|/**      *<p>Create a new {@link Path Path} instance.</p>      *       * @throws ClassCastException if any of the elements in the {@link List}      *                            was not a {@link Path.Element Element}.      */
specifier|public
name|Path
parameter_list|(
name|List
name|elements
parameter_list|,
name|boolean
name|absolute
parameter_list|,
name|boolean
name|collection
parameter_list|)
block|{
name|this
argument_list|(
name|elements
argument_list|,
name|absolute
argument_list|,
name|collection
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>Create a new {@link Path Path} instance.</p>      *       * @throws ClassCastException if any of the elements in the {@link List}      *                            was not a {@link Path.Element Element}.      */
specifier|public
name|Path
parameter_list|(
name|List
name|elements
parameter_list|,
name|boolean
name|absolute
parameter_list|,
name|boolean
name|collection
parameter_list|,
name|Parameters
name|parameters
parameter_list|)
block|{
specifier|final
name|Stack
name|resolved
init|=
name|resolve
argument_list|(
literal|null
argument_list|,
name|absolute
argument_list|,
name|elements
argument_list|)
decl_stmt|;
specifier|final
name|Element
name|array
index|[]
init|=
operator|new
name|Element
index|[
name|resolved
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|this
operator|.
name|paths
operator|=
operator|(
name|Element
index|[]
operator|)
name|resolved
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|this
operator|.
name|parameters
operator|=
name|parameters
expr_stmt|;
name|this
operator|.
name|absolute
operator|=
name|absolute
expr_stmt|;
name|this
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|EncodingTools
operator|.
name|toString
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/* ====================================================================== */
comment|/* STATIC CONSTRUCTION METHODS                                            */
comment|/* ====================================================================== */
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} structure.</p>      */
specifier|public
specifier|static
name|Path
name|parse
parameter_list|(
name|String
name|path
parameter_list|)
block|{
try|try
block|{
return|return
name|parse
argument_list|(
name|path
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} structure.</p>      */
specifier|public
specifier|static
name|Path
name|parse
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
specifier|final
name|List
name|params
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|final
name|List
name|elems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* No path, flog it! */
if|if
condition|(
operator|(
name|path
operator|==
literal|null
operator|)
operator|||
operator|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|elems
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/* Check for a proper encoding */
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
comment|/* Split up the path structure into its path element components */
specifier|final
name|String
name|split
index|[]
init|=
name|StringTools
operator|.
name|splitAll
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
comment|/* Check if this path is an absolute path */
specifier|final
name|boolean
name|absolute
init|=
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
decl_stmt|;
comment|/* Check every single path element and append it to the current one */
name|Element
name|element
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|split
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|split
index|[
name|x
index|]
operator|==
literal|null
condition|)
continue|continue;
comment|/* Collapse double slashes */
name|element
operator|=
name|parsePath
argument_list|(
name|split
index|[
name|x
index|]
argument_list|,
name|params
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
name|elems
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
comment|/* Check if this is a collection */
specifier|final
name|boolean
name|collection
init|=
operator|(
operator|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|null
operator|)
operator|||
operator|(
name|element
operator|==
literal|null
operator|)
operator|||
name|element
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
operator|||
name|element
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
operator|)
decl_stmt|;
comment|/* Setup the last path in our chain and return the first one */
specifier|final
name|Parameters
name|parameters
init|=
name|Parameters
operator|.
name|create
argument_list|(
name|params
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|elems
argument_list|,
name|absolute
argument_list|,
name|collection
argument_list|,
name|parameters
argument_list|)
return|;
block|}
comment|/* ====================================================================== */
comment|/**      *<p>Parse a single path element like<code>path!extra;param</code>.</p>      */
specifier|private
specifier|static
name|Element
name|parsePath
parameter_list|(
name|String
name|path
parameter_list|,
name|List
name|parameters
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
specifier|final
name|int
name|pathEnds
init|=
name|StringTools
operator|.
name|findFirst
argument_list|(
name|path
argument_list|,
literal|"!;"
argument_list|)
decl_stmt|;
specifier|final
name|Element
name|element
decl_stmt|;
if|if
condition|(
name|pathEnds
operator|<
literal|0
condition|)
block|{
name|element
operator|=
operator|new
name|Element
argument_list|(
name|EncodingTools
operator|.
name|urlDecode
argument_list|(
name|path
argument_list|,
name|encoding
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|path
operator|.
name|charAt
argument_list|(
name|pathEnds
argument_list|)
operator|==
literal|';'
condition|)
block|{
comment|// --> pathname;pathparameter
specifier|final
name|String
name|name
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pathEnds
argument_list|)
decl_stmt|;
specifier|final
name|String
name|param
init|=
name|path
operator|.
name|substring
argument_list|(
name|pathEnds
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Parameters
name|params
init|=
name|Parameters
operator|.
name|parse
argument_list|(
name|param
argument_list|,
literal|';'
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
name|parameters
operator|.
name|addAll
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|element
operator|=
operator|new
name|Element
argument_list|(
name|EncodingTools
operator|.
name|urlDecode
argument_list|(
name|name
argument_list|,
name|encoding
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// --> pathname!extra...
specifier|final
name|String
name|name
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pathEnds
argument_list|)
decl_stmt|;
specifier|final
name|String
name|more
init|=
name|path
operator|.
name|substring
argument_list|(
name|pathEnds
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|split
index|[]
init|=
name|StringTools
operator|.
name|splitOnce
argument_list|(
name|more
argument_list|,
literal|';'
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Parameters
name|params
init|=
name|Parameters
operator|.
name|parse
argument_list|(
name|split
index|[
literal|1
index|]
argument_list|,
literal|';'
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
name|parameters
operator|.
name|addAll
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|element
operator|=
operator|new
name|Element
argument_list|(
name|EncodingTools
operator|.
name|urlDecode
argument_list|(
name|name
argument_list|,
name|encoding
argument_list|)
argument_list|,
name|EncodingTools
operator|.
name|urlDecode
argument_list|(
name|split
index|[
literal|0
index|]
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|element
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|element
return|;
block|}
comment|/* ====================================================================== */
comment|/* RESOLUTION METHODS                                                     */
comment|/* ====================================================================== */
comment|/**      *<p>Resolve the specified {@link Path} against this one.</p>      */
specifier|public
name|Path
name|resolve
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
comment|/* Merge the parameters */
specifier|final
name|List
name|params
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|parameters
operator|!=
literal|null
condition|)
name|params
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|parameters
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|parameters
operator|!=
literal|null
condition|)
name|params
operator|.
name|addAll
argument_list|(
name|path
operator|.
name|parameters
argument_list|)
expr_stmt|;
specifier|final
name|Parameters
name|parameters
init|=
name|Parameters
operator|.
name|create
argument_list|(
name|params
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
comment|/* No path, return this instance */
if|if
condition|(
name|path
operator|==
literal|null
condition|)
return|return
name|this
return|;
comment|/* If the target is absolute, only merge the parameters */
if|if
condition|(
name|path
operator|.
name|absolute
condition|)
return|return
operator|new
name|Path
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
name|path
operator|.
name|collection
argument_list|,
name|parameters
argument_list|)
return|;
comment|/* Resolve the path */
specifier|final
name|Stack
name|source
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
name|source
operator|.
name|addAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|collection
operator|&&
operator|(
name|source
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
name|source
operator|.
name|pop
argument_list|()
expr_stmt|;
specifier|final
name|List
name|resolved
init|=
name|resolve
argument_list|(
name|source
argument_list|,
name|this
operator|.
name|absolute
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* Figure out if the resolved path is a collection and return it */
specifier|final
name|boolean
name|c
init|=
name|path
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
name|this
operator|.
name|collection
else|:
name|path
operator|.
name|collection
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|resolved
argument_list|,
name|this
operator|.
name|absolute
argument_list|,
name|c
argument_list|,
name|parameters
argument_list|)
return|;
block|}
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} and resolve it      * against this one.</p>      */
specifier|public
name|Path
name|resolve
parameter_list|(
name|String
name|path
parameter_list|)
block|{
try|try
block|{
return|return
name|this
operator|.
name|resolve
argument_list|(
name|parse
argument_list|(
name|path
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} and resolve it      * against this one.</p>      *       * @throws NullPointerException if the path {@link String} was<b>null</b>.      */
specifier|public
name|Path
name|resolve
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
return|return
name|this
return|;
return|return
name|this
operator|.
name|resolve
argument_list|(
name|parse
argument_list|(
name|path
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
comment|/* ====================================================================== */
specifier|private
specifier|static
name|Stack
name|resolve
parameter_list|(
name|Stack
name|stack
parameter_list|,
name|boolean
name|absolute
parameter_list|,
name|List
name|elements
parameter_list|)
block|{
comment|/* If we have no source stack we create a new empty one */
if|if
condition|(
name|stack
operator|==
literal|null
condition|)
name|stack
operator|=
operator|new
name|Stack
argument_list|()
expr_stmt|;
comment|/* A flag indicating whether we are at the "root" path element. */
name|boolean
name|atroot
init|=
name|absolute
operator|&&
name|stack
operator|.
name|empty
argument_list|()
decl_stmt|;
comment|/* Iterate through the current path elements to see what to do. */
for|for
control|(
name|Iterator
name|iter
init|=
name|elements
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|Element
name|element
init|=
operator|(
name|Element
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|/* If this is the "." (current) path element, skip it. */
if|if
condition|(
literal|"."
operator|.
name|equals
argument_list|(
name|element
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
continue|continue;
comment|/* If this is the ".." (parent) path element, it gets nasty. */
if|if
condition|(
literal|".."
operator|.
name|equals
argument_list|(
name|element
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|/* The root path's parent is always itself */
if|if
condition|(
name|atroot
condition|)
continue|continue;
comment|/* We're not at root and have the stack, relative ".." */
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* We're not at root, but we have stuff in the stack */
block|}
else|else
block|{
comment|/* Get the last element in the stack */
specifier|final
name|Element
name|prev
init|=
operator|(
name|Element
operator|)
name|stack
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|/* If the last element is "..", add another one */
if|if
condition|(
literal|".."
operator|.
name|equals
argument_list|(
name|prev
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
name|stack
operator|.
name|push
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* The last element was not "..", pop it out */
else|else
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
comment|/* If absoulte and stack is empty, we're at root */
if|if
condition|(
name|absolute
condition|)
name|atroot
operator|=
name|stack
operator|.
name|size
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Normal element processing follows... */
name|stack
operator|.
name|push
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|atroot
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|stack
return|;
block|}
comment|/* ====================================================================== */
comment|/* RELATIVIZATION METHODS                                                 */
comment|/* ====================================================================== */
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} and relativize      * it against this one.</p>      */
specifier|public
name|Path
name|relativize
parameter_list|(
name|String
name|path
parameter_list|)
block|{
try|try
block|{
return|return
name|this
operator|.
name|relativize
argument_list|(
name|parse
argument_list|(
name|path
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|exception
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Unsupported encoding "
operator|+
name|DEFAULT_ENCODING
decl_stmt|;
specifier|final
name|InternalError
name|error
init|=
operator|new
name|InternalError
argument_list|(
name|message
argument_list|)
decl_stmt|;
throw|throw
operator|(
name|InternalError
operator|)
name|error
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      *<p>Parse the specified {@link String} into a {@link Path} and relativize      * it against this one.</p>      */
specifier|public
name|Path
name|relativize
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
name|encoding
operator|=
name|DEFAULT_ENCODING
expr_stmt|;
return|return
name|this
operator|.
name|relativize
argument_list|(
name|parse
argument_list|(
name|path
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
comment|/**      *<p>Retrieve the relativization path from this {@link Path} to the      * specified {@link Path}.</p>      */
specifier|public
name|Path
name|relativize
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
comment|/* No matter what, always return the aggregate of all parameters */
specifier|final
name|List
name|parameters
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|parameters
operator|!=
literal|null
condition|)
name|parameters
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|parameters
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|parameters
operator|!=
literal|null
condition|)
name|parameters
operator|.
name|addAll
argument_list|(
name|path
operator|.
name|parameters
argument_list|)
expr_stmt|;
specifier|final
name|Parameters
name|params
init|=
name|Parameters
operator|.
name|create
argument_list|(
name|parameters
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
comment|/* We are absolute and the specified path is absolute, we process */
if|if
condition|(
operator|(
name|path
operator|.
name|absolute
operator|)
operator|&&
operator|(
name|this
operator|.
name|absolute
operator|)
condition|)
block|{
comment|/* Find the max number of paths we should examine */
specifier|final
name|int
name|num
init|=
name|this
operator|.
name|collection
condition|?
name|this
operator|.
name|size
argument_list|()
else|:
name|this
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|/* Process the two absolute paths to check common elements */
name|int
name|skip
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
operator|(
name|x
operator|<
name|num
operator|)
operator|&&
operator|(
name|x
operator|<
name|path
operator|.
name|size
argument_list|()
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|path
operator|.
name|paths
index|[
name|x
index|]
operator|.
name|equals
argument_list|(
name|this
operator|.
name|paths
index|[
name|x
index|]
argument_list|)
condition|)
name|skip
operator|++
expr_stmt|;
else|else
break|break;
block|}
comment|/* Figure out if the resulting path is a collection */
specifier|final
name|boolean
name|collection
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>
name|skip
condition|)
name|collection
operator|=
name|path
operator|.
name|collection
expr_stmt|;
if|else if
condition|(
name|this
operator|.
name|size
argument_list|()
operator|>
name|skip
condition|)
name|collection
operator|=
literal|true
expr_stmt|;
else|else
name|collection
operator|=
name|this
operator|.
name|collection
expr_stmt|;
comment|/* Recreate the path to return by adding ".." and the paths */
specifier|final
name|List
name|elems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
name|skip
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
name|elems
operator|.
name|add
argument_list|(
operator|new
name|Element
argument_list|(
literal|".."
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|.
name|addAll
argument_list|(
name|path
operator|.
name|subList
argument_list|(
name|skip
argument_list|,
name|path
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|elems
argument_list|,
literal|false
argument_list|,
name|collection
argument_list|)
return|;
block|}
comment|/*          * Here we are in one of the following cases:          * - the specified path is already relative, so why bother?          * - we are relative and the specified path is absolute: in this case          *   we can't possibly know how far away we are located from the root          *   so, we only have one option, to return the absolute path.          * In all cases, though, before returning the specified path, we just          * merge ours and the path's parameters.           */
if|if
condition|(
name|this
operator|.
name|absolute
operator|&&
operator|(
operator|!
name|path
operator|.
name|absolute
operator|)
condition|)
block|{
comment|/*              * Ok, let's bother, we're absolute and the specified is not. This              * means that if we resolve the path, we can find another absolute              * path, and therefore we can do a better job at relativizin it.              */
return|return
name|this
operator|.
name|relativize
argument_list|(
name|this
operator|.
name|resolve
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
comment|/* We'll never going to be able to do better than this */
return|return
operator|new
name|Path
argument_list|(
name|path
argument_list|,
name|path
operator|.
name|absolute
argument_list|,
name|path
operator|.
name|collection
argument_list|,
name|params
argument_list|)
return|;
block|}
comment|/* ====================================================================== */
comment|/* PUBLIC EXPOSED METHODS                                                 */
comment|/* ====================================================================== */
comment|/**      *<p>Return the {@link Path.Element Element} instance at      * the specified index.</p>      */
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|this
operator|.
name|paths
index|[
name|index
index|]
return|;
block|}
comment|/**      *<p>Return the number of {@link Path.Element Element}      * instances contained by this instance.</p>      */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|paths
operator|.
name|length
return|;
block|}
comment|/**      *<p>Checks if this {@link Path Path} instance represents      * an absolute path.</p>      */
specifier|public
name|boolean
name|isAbsolute
parameter_list|()
block|{
return|return
name|this
operator|.
name|absolute
return|;
block|}
comment|/**      *<p>Checks if this {@link Path Path} instance represents      * a collection.</p>      */
specifier|public
name|boolean
name|isCollection
parameter_list|()
block|{
return|return
name|this
operator|.
name|collection
return|;
block|}
comment|/**      *<p>Returns the collection of {@link Parameters Parameters}      * contained by this instance or<b>null</b>.</p>      */
specifier|public
name|Parameters
name|getParameters
parameter_list|()
block|{
return|return
name|this
operator|.
name|parameters
return|;
block|}
comment|/* ====================================================================== */
comment|/* OBJECT METHODS                                                         */
comment|/* ====================================================================== */
comment|/**      *<p>Return the URL-encoded {@link String} representation of this      * {@link Path Path} instance.</p>      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
return|;
block|}
comment|/**      *<p>Return the URL-encoded {@link String} representation of this      * {@link Path Path} instance using the specified      * character encoding.</p>      */
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|absolute
condition|)
name|buffer
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
specifier|final
name|int
name|last
init|=
name|this
operator|.
name|paths
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|last
condition|;
name|x
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|this
operator|.
name|paths
index|[
name|x
index|]
operator|.
name|toString
argument_list|(
name|encoding
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>=
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|this
operator|.
name|paths
index|[
name|last
index|]
operator|.
name|toString
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|collection
condition|)
name|buffer
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|parameters
operator|!=
literal|null
condition|)
name|buffer
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
operator|.
name|append
argument_list|(
name|this
operator|.
name|parameters
operator|.
name|toString
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      *<p>Return the hash code value of this      * {@link Path Path} instance.</p>      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      *<p>Check if the specified {@link Object} is equal to this      * {@link Path Path} instance.</p>      *       *<p>The specified {@link Object} is considered equal to this one if      * it is<b>non-null</b>, is a {@link Path Path}      * instance and its {@link #toString() string representation} equals      * this one's.</p>      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
operator|(
name|object
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|object
operator|instanceof
name|Path
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|string
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Path
operator|)
name|object
operator|)
operator|.
name|string
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* ====================================================================== */
comment|/* PUBLIC INNER CLASSES                                                   */
comment|/* ====================================================================== */
comment|/**      *<p>The {@link Path.Element Element} class represents a path      * element within the {@link Path Path} structure.</p>      *      * @author<a href="http://could.it/">Pier Fumagalli</a>      */
specifier|public
specifier|static
class|class
name|Element
implements|implements
name|Encodable
block|{
comment|/**<p>The name of this path element (decoded).</p> */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**<p>The extra path information of this path element (decoded).</p> */
specifier|private
specifier|final
name|String
name|extra
decl_stmt|;
comment|/**<p>The {@link String} representation of this (encoded).</p> */
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
comment|/**          *<p>Create a new {@link Path.Element Element} instance given its          * url-decoded components name and extra.</p>          *           * @throws NullPointerException if the specified name was<b>null</b>.          */
specifier|public
name|Element
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|extra
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null path name"
argument_list|)
throw|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|extra
operator|=
name|extra
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|EncodingTools
operator|.
name|toString
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/* ================================================================== */
comment|/* PUBLIC EXPOSED METHODS                                             */
comment|/* ================================================================== */
comment|/**          *<p>Return the url-decoded {@link String} name of this          * {@link Path.Element Element}.</p>          */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/**          *<p>Return the url-decoded {@link String} extra path of this          * {@link Path.Element Element}.</p>          */
specifier|public
name|String
name|getExtra
parameter_list|()
block|{
return|return
name|this
operator|.
name|extra
return|;
block|}
comment|/* ================================================================== */
comment|/* OBJECT METHODS                                                     */
comment|/* ================================================================== */
comment|/**          *<p>Return the URL-encoded {@link String} representation of this          * {@link Path.Element Element} instance.</p>          */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
return|;
block|}
comment|/**          *<p>Return the URL-encoded {@link String} representation of this          * {@link Path.Element Element} instance using the specified          * character encoding.</p>          */
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|encoding
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
specifier|final
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|EncodingTools
operator|.
name|urlEncode
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|extra
operator|!=
literal|null
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|EncodingTools
operator|.
name|urlEncode
argument_list|(
name|this
operator|.
name|extra
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          *<p>Return the hash code value of this          * {@link Path.Element Element} instance.</p>          */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|string
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**          *<p>Check if the specified {@link Object} is equal to this          * {@link Path.Element Element} instance.</p>          *           *<p>The specified {@link Object} is considered equal to this one if          * it is<b>non-null</b>, is a {@link Path.Element Element}          * instance and its {@link #toString() string representation} equals          * this one's.</p>          */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
operator|(
name|object
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|object
operator|instanceof
name|Element
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|string
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Element
operator|)
name|object
operator|)
operator|.
name|string
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

