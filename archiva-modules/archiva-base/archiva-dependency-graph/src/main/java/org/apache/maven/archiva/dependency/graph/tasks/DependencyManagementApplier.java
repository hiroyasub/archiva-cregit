begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|tasks
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *  http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|DependencyGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|DependencyGraphBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|DependencyGraphEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|DependencyGraphNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|DependencyGraphUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|tasks
operator|.
name|DependencyManagementStack
operator|.
name|Rules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|walk
operator|.
name|BaseVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|dependency
operator|.
name|graph
operator|.
name|walk
operator|.
name|DependencyGraphVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|model
operator|.
name|ArtifactReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|archiva
operator|.
name|model
operator|.
name|VersionedReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Takes a stack of DependencyManagement objects and applies them to the node in question.  * This merely sets the version / scope / and exclusions on the nodes, as defined by DependencyManagement.  *   * @author<a href="mailto:joakime@apache.org">Joakim Erdfelt</a>  * @version $Id$  */
end_comment

begin_class
specifier|public
class|class
name|DependencyManagementApplier
extends|extends
name|BaseVisitor
implements|implements
name|DependencyGraphVisitor
block|{
specifier|private
name|DependencyManagementStack
name|depStack
init|=
operator|new
name|DependencyManagementStack
argument_list|()
decl_stmt|;
specifier|private
name|DependencyGraphBuilder
name|builder
decl_stmt|;
comment|/**      * Map of changes to node versions (that will likely cause a reorganization of      * the graph), this is tracked until the walk is complete, at which point the      * changes are applied to the graph.      *       * Performing graph changes of this scope during a walk of graph is hazardous,      * as you will be moving nodes around, mergeing nodes, dropping edges, etc.      */
specifier|private
name|Map
name|nodeVersionChanges
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nodesAdded
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|discoverGraph
parameter_list|(
name|DependencyGraph
name|graph
parameter_list|)
block|{
name|super
operator|.
name|discoverGraph
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|nodeVersionChanges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|depStack
operator|.
name|reset
argument_list|()
expr_stmt|;
name|nodesAdded
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|discoverNode
parameter_list|(
name|DependencyGraphNode
name|node
parameter_list|)
block|{
name|super
operator|.
name|discoverNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|depStack
operator|.
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|List
name|edgesFrom
init|=
name|graph
operator|.
name|getEdgesFrom
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|edgesFrom
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DependencyGraphEdge
name|edge
init|=
operator|(
name|DependencyGraphEdge
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Rules
name|rules
init|=
name|depStack
operator|.
name|getRules
argument_list|(
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|rules
operator|==
literal|null
condition|)
block|{
comment|// No rules for edge, skip it.
continue|continue;
block|}
name|DependencyGraphNode
name|subnode
init|=
name|graph
operator|.
name|getNode
argument_list|(
name|edge
operator|.
name|getNodeTo
argument_list|()
argument_list|)
decl_stmt|;
comment|/* There are 3 steps to processing the DependencyManagement. */
comment|/* 1) Add exclusions to node ________________________________________________ */
name|node
operator|.
name|getExcludes
argument_list|()
operator|.
name|addAll
argument_list|(
name|rules
operator|.
name|exclusions
argument_list|)
expr_stmt|;
comment|/* 2) Track version changes to node _________________________________________ */
comment|// This is the version as specified by the rules.
name|String
name|specifiedVersion
init|=
name|rules
operator|.
name|artifact
operator|.
name|getVersion
argument_list|()
decl_stmt|;
comment|// This is the version as being tracked by the nodeVersionChanges map.
name|String
name|trackedVersion
init|=
operator|(
name|String
operator|)
name|nodeVersionChanges
operator|.
name|get
argument_list|(
name|edge
operator|.
name|getNodeTo
argument_list|()
argument_list|)
decl_stmt|;
comment|// This is the version of the subnode.
name|String
name|nodeVersion
init|=
name|subnode
operator|.
name|getArtifact
argument_list|()
operator|.
name|getVersion
argument_list|()
decl_stmt|;
comment|// This is the actual version as determined by tracked and subnode
name|String
name|actualVersion
init|=
name|StringUtils
operator|.
name|defaultString
argument_list|(
name|trackedVersion
argument_list|,
name|nodeVersion
argument_list|)
decl_stmt|;
comment|// If the specified version changes the actual version ...
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|equals
argument_list|(
name|specifiedVersion
argument_list|,
name|actualVersion
argument_list|)
condition|)
block|{
comment|// ... save this new value to be track ( for processing in #finishedGraph )
name|nodeVersionChanges
operator|.
name|put
argument_list|(
name|edge
operator|.
name|getNodeTo
argument_list|()
argument_list|,
name|specifiedVersion
argument_list|)
expr_stmt|;
block|}
comment|/* 3) Update scope to edge __________________________________________________ */
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|rules
operator|.
name|scope
argument_list|)
condition|)
block|{
name|edge
operator|.
name|setScope
argument_list|(
name|rules
operator|.
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|finishNode
parameter_list|(
name|DependencyGraphNode
name|node
parameter_list|)
block|{
name|super
operator|.
name|finishNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|depStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|finishGraph
parameter_list|(
name|DependencyGraph
name|graph
parameter_list|)
block|{
name|super
operator|.
name|finishGraph
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|Iterator
name|it
init|=
name|this
operator|.
name|nodeVersionChanges
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ArtifactReference
name|ref
init|=
operator|(
name|ArtifactReference
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|toVersion
init|=
operator|(
name|String
operator|)
name|this
operator|.
name|nodeVersionChanges
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|collapseVersions
argument_list|(
name|graph
argument_list|,
name|ref
argument_list|,
name|ref
operator|.
name|getVersion
argument_list|()
argument_list|,
name|toVersion
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Collapses Versions of nodes.      *       * Takes two nodes, with differing versions.      *       * 1) Removes the FROM edges connected to the FROM node      * 2) Moves the TO edges connected to the FROM node to the TO node.      * 3) Removes the FROM node (which is now orphaned)        *        * @param graph the graph to perform operation on      * @param fromRef the artifact reference of the FROM node.      * @param fromVersion the version of the FROM node      * @param toVersion the version of the TO node      */
specifier|private
name|void
name|collapseVersions
parameter_list|(
name|DependencyGraph
name|graph
parameter_list|,
name|ArtifactReference
name|fromRef
parameter_list|,
name|String
name|fromVersion
parameter_list|,
name|String
name|toVersion
parameter_list|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|fromVersion
argument_list|,
name|toVersion
argument_list|)
condition|)
block|{
comment|// No point in doing anything.  nothing has changed.
return|return;
block|}
name|ArtifactReference
name|toRef
init|=
operator|new
name|ArtifactReference
argument_list|()
decl_stmt|;
name|toRef
operator|.
name|setGroupId
argument_list|(
name|fromRef
operator|.
name|getGroupId
argument_list|()
argument_list|)
expr_stmt|;
name|toRef
operator|.
name|setArtifactId
argument_list|(
name|fromRef
operator|.
name|getArtifactId
argument_list|()
argument_list|)
expr_stmt|;
name|toRef
operator|.
name|setVersion
argument_list|(
name|toVersion
argument_list|)
expr_stmt|;
name|toRef
operator|.
name|setClassifier
argument_list|(
name|fromRef
operator|.
name|getClassifier
argument_list|()
argument_list|)
expr_stmt|;
name|toRef
operator|.
name|setType
argument_list|(
name|fromRef
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|DependencyGraphNode
name|nodeFROM
init|=
name|graph
operator|.
name|getNode
argument_list|(
name|fromRef
argument_list|)
decl_stmt|;
name|DependencyGraphNode
name|nodeTO
init|=
name|graph
operator|.
name|getNode
argument_list|(
name|toRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeTO
operator|==
literal|null
condition|)
block|{
comment|// new node doesn't exist in graph (yet)
name|nodeTO
operator|=
operator|new
name|DependencyGraphNode
argument_list|(
name|toRef
argument_list|)
expr_stmt|;
name|nodeTO
operator|.
name|setResolved
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|graph
operator|.
name|addNode
argument_list|(
name|nodeTO
argument_list|)
expr_stmt|;
name|VersionedReference
name|projectRef
init|=
operator|new
name|VersionedReference
argument_list|()
decl_stmt|;
name|projectRef
operator|.
name|setGroupId
argument_list|(
name|toRef
operator|.
name|getGroupId
argument_list|()
argument_list|)
expr_stmt|;
name|projectRef
operator|.
name|setArtifactId
argument_list|(
name|toRef
operator|.
name|getArtifactId
argument_list|()
argument_list|)
expr_stmt|;
name|projectRef
operator|.
name|setVersion
argument_list|(
name|toRef
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|resolveNode
argument_list|(
name|graph
argument_list|,
name|nodeTO
argument_list|,
name|projectRef
argument_list|)
expr_stmt|;
name|nodesAdded
operator|++
expr_stmt|;
block|}
name|DependencyGraphUtils
operator|.
name|collapseNodes
argument_list|(
name|graph
argument_list|,
name|nodeFROM
argument_list|,
name|nodeTO
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DependencyGraphBuilder
name|getBuilder
parameter_list|()
block|{
return|return
name|builder
return|;
block|}
specifier|public
name|void
name|setBuilder
parameter_list|(
name|DependencyGraphBuilder
name|builder
parameter_list|)
block|{
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasCreatedNodes
parameter_list|()
block|{
return|return
operator|(
name|nodesAdded
operator|>
literal|0
operator|)
return|;
block|}
block|}
end_class

end_unit

