begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|archiva
operator|.
name|repository
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|StreamSupport
import|;
end_import

begin_comment
comment|/**  *  * Base Spliterator implementation for Storage Assets. The spliterator visits the tree by depth-first.  * For the non-concurrent usage it is guaranteed that children are visited before their  * parents. If the spliterator is used in a parallel stream, there is no guarantee for  * the order of returned assets.  *  * The estimated size is not accurate, because the tree paths are scanned on demand.  *  * @since 3.0  * @author Martin Stockhammer<martin_s@apache.org>  */
end_comment

begin_class
specifier|public
class|class
name|AssetSpliterator
implements|implements
name|Spliterator
argument_list|<
name|StorageAsset
argument_list|>
implements|,
name|Closeable
block|{
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SPLIT_THRESHOLD
init|=
literal|2
decl_stmt|;
comment|// the linked list is used as stack
specifier|private
name|LinkedList
argument_list|<
name|StorageAsset
argument_list|>
name|workList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|( )
decl_stmt|;
specifier|private
name|LinkedHashSet
argument_list|<
name|StorageAsset
argument_list|>
name|visitedContainers
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|( )
decl_stmt|;
specifier|private
name|long
name|visited
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|splitThreshold
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHARACTERISTICS
init|=
name|Spliterator
operator|.
name|DISTINCT
operator||
name|Spliterator
operator|.
name|NONNULL
decl_stmt|;
name|AssetSpliterator
parameter_list|(
name|int
name|splitThreshold
parameter_list|,
name|StorageAsset
modifier|...
name|assets
parameter_list|)
block|{
name|this
operator|.
name|splitThreshold
operator|=
name|splitThreshold
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|workList
argument_list|,
name|assets
argument_list|)
expr_stmt|;
block|}
name|AssetSpliterator
parameter_list|(
name|StorageAsset
modifier|...
name|assets
parameter_list|)
block|{
name|this
operator|.
name|splitThreshold
operator|=
name|DEFAULT_SPLIT_THRESHOLD
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|workList
argument_list|,
name|assets
argument_list|)
expr_stmt|;
block|}
name|AssetSpliterator
parameter_list|()
block|{
name|this
operator|.
name|splitThreshold
operator|=
name|DEFAULT_SPLIT_THRESHOLD
expr_stmt|;
block|}
name|AssetSpliterator
parameter_list|(
name|int
name|splitThreshold
parameter_list|)
block|{
name|this
operator|.
name|splitThreshold
operator|=
name|splitThreshold
expr_stmt|;
block|}
name|AssetSpliterator
parameter_list|(
name|int
name|splitThreshold
parameter_list|,
name|Set
argument_list|<
name|StorageAsset
argument_list|>
name|visitedContainers
parameter_list|)
block|{
name|this
operator|.
name|visitedContainers
operator|.
name|addAll
argument_list|(
name|visitedContainers
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitThreshold
operator|=
name|splitThreshold
expr_stmt|;
block|}
name|AssetSpliterator
parameter_list|(
name|List
argument_list|<
name|StorageAsset
argument_list|>
name|baseList
parameter_list|,
name|Set
argument_list|<
name|StorageAsset
argument_list|>
name|visitedContainers
parameter_list|)
block|{
name|this
operator|.
name|workList
operator|.
name|addAll
argument_list|(
name|baseList
argument_list|)
expr_stmt|;
name|this
operator|.
name|visitedContainers
operator|.
name|addAll
argument_list|(
name|visitedContainers
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitThreshold
operator|=
name|DEFAULT_SPLIT_THRESHOLD
expr_stmt|;
block|}
specifier|private
name|void
name|add
parameter_list|(
name|StorageAsset
name|asset
parameter_list|)
block|{
name|workList
operator|.
name|addLast
argument_list|(
name|asset
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|( )
block|{
name|this
operator|.
name|workList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|workList
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|visitedContainers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|visitedContainers
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|StorageAsset
argument_list|>
name|action
parameter_list|)
block|{
try|try
block|{
name|StorageAsset
name|asset
init|=
name|workList
operator|.
name|getLast
argument_list|( )
decl_stmt|;
name|consumeAsset
argument_list|(
name|action
argument_list|,
name|asset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|void
name|consumeAsset
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|StorageAsset
argument_list|>
name|action
parameter_list|,
name|StorageAsset
name|asset
parameter_list|)
block|{
comment|// Traverse the path to the deepest descent (depth-first)
while|while
condition|(
name|retrieveNextPath
argument_list|(
name|asset
argument_list|)
condition|)
block|{
name|asset
operator|=
name|workList
operator|.
name|getLast
argument_list|( )
expr_stmt|;
block|}
name|action
operator|.
name|accept
argument_list|(
name|workList
operator|.
name|removeLast
argument_list|()
argument_list|)
expr_stmt|;
name|visited
operator|++
expr_stmt|;
block|}
specifier|private
name|boolean
name|retrieveNextPath
parameter_list|(
name|StorageAsset
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|.
name|isContainer
argument_list|()
operator|&&
operator|!
name|visitedContainers
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
comment|// Containers after files in stack guarantee the depth-first behaviour
name|workList
operator|.
name|addAll
argument_list|(
name|getChildFiles
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|workList
operator|.
name|addAll
argument_list|(
name|getChildContainers
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|visitedContainers
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|forEachRemaining
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|StorageAsset
argument_list|>
name|action
parameter_list|)
block|{
try|try
block|{
comment|//noinspection InfiniteLoopStatement
while|while
condition|(
literal|true
condition|)
block|{
name|consumeAsset
argument_list|(
name|action
argument_list|,
name|workList
operator|.
name|getLast
argument_list|( )
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
comment|// Should happen at the end.
block|}
block|}
comment|// In reverse order
name|List
argument_list|<
name|StorageAsset
argument_list|>
name|getChildContainers
parameter_list|(
name|StorageAsset
name|parent
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|StorageAsset
argument_list|>
name|children
init|=
name|parent
operator|.
name|list
argument_list|( )
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|children
operator|.
name|size
argument_list|( )
decl_stmt|;
return|return
name|IntStream
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|children
operator|.
name|size
argument_list|( )
argument_list|)
operator|.
name|mapToObj
argument_list|(
name|i
lambda|->
name|children
operator|.
name|get
argument_list|(
name|len
operator|-
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|StorageAsset
operator|::
name|isContainer
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|( )
argument_list|)
return|;
block|}
comment|// In reverse order
name|List
argument_list|<
name|StorageAsset
argument_list|>
name|getChildFiles
parameter_list|(
name|StorageAsset
name|parent
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|StorageAsset
argument_list|>
name|children
init|=
name|parent
operator|.
name|list
argument_list|( )
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|children
operator|.
name|size
argument_list|( )
decl_stmt|;
return|return
name|IntStream
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|children
operator|.
name|size
argument_list|( )
argument_list|)
operator|.
name|mapToObj
argument_list|(
name|i
lambda|->
name|children
operator|.
name|get
argument_list|(
name|len
operator|-
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|StorageAsset
operator|::
name|isLeaf
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|( )
argument_list|)
return|;
block|}
comment|/**      * Splits by moving every second asset to the new spliterator. This allows to start both at similar      * tree depths. But it is not guaranteed that they start on the same depth.      * The split happens only, if the number of elements in the worklist is greater than 2.      *      * @return the new spliterator if the work list size is greater than 2      */
annotation|@
name|Override
specifier|public
name|Spliterator
argument_list|<
name|StorageAsset
argument_list|>
name|trySplit
parameter_list|( )
block|{
if|if
condition|(
name|workList
operator|.
name|size
argument_list|()
operator|>
name|splitThreshold
condition|)
block|{
comment|// We use the elements alternately for the current and the new spliterator
comment|// For the parallel scenario we cannot guarantee that children are visited
comment|// before their parents
specifier|final
name|LinkedList
argument_list|<
name|StorageAsset
argument_list|>
name|newWorkList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|( )
decl_stmt|;
specifier|final
name|AssetSpliterator
name|newSpliterator
init|=
operator|new
name|AssetSpliterator
argument_list|(
name|this
operator|.
name|splitThreshold
argument_list|,
name|visitedContainers
argument_list|)
decl_stmt|;
try|try
block|{
comment|//noinspection InfiniteLoopStatement
while|while
condition|(
literal|true
condition|)
block|{
name|newWorkList
operator|.
name|add
argument_list|(
name|workList
operator|.
name|getFirst
argument_list|( )
argument_list|)
expr_stmt|;
name|newSpliterator
operator|.
name|add
argument_list|(
name|workList
operator|.
name|getFirst
argument_list|( )
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
comment|//
block|}
comment|// Swap the worklist
name|this
operator|.
name|workList
operator|=
name|newWorkList
expr_stmt|;
return|return
name|newSpliterator
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|estimateSize
parameter_list|( )
block|{
return|return
name|workList
operator|.
name|size
argument_list|()
operator|+
name|visited
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|characteristics
parameter_list|( )
block|{
return|return
name|CHARACTERISTICS
return|;
block|}
block|}
end_class

end_unit

